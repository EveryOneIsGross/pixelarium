<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pixelarium</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
        }
        canvas { 
            display: block; 
            image-rendering: pixelated;
            width: 100vw;
            height: 100dvh;
            margin: 0 auto;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
            background: #333;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background: #555;
        }
        #swatch {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: row;
            gap: 2px;
            flex-wrap: wrap;
            max-width: calc(100vw);
        }
        .material-btn {
            width: 25px;
            height: 25px;
            border: 2px solid #666;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }
        .material-btn.selected {
            border-color: #fff;
            box-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>

    <div id="swatch">
        <div class="material-btn" onclick="toggleMenu()" style="background: #555; color: #000;" id="menuToggle"></div>
        <div class="material-btn toggleable selected" onclick="selectMaterial('SAND')" style="background: #dcb870; color: #000;"></div>
        <div class="material-btn toggleable" onclick="selectMaterial('WATER')" style="background: #4a90e2; color: #fff;"></div>
        <div class="material-btn toggleable" onclick="selectMaterial('FIRE')" style="background: #ff6b35; color: #fff;"></div>
        <div class="material-btn toggleable" onclick="selectMaterial('DIRT')" style="background: #8b4513; color: #fff;"></div>
        <div class="material-btn toggleable" onclick="selectMaterial('TREE')" style="background: #228b22; color: #fff;"></div>
        <div class="material-btn toggleable" onclick="selectMaterial('GLASS')" style="background: #b4dcf0; color: #000;"></div>
        <div class="material-btn toggleable" onclick="selectMaterial('STEAM')" style="background: #f0f0f0; color: #000;"></div>
        <div class="material-btn toggleable" onclick="selectMaterial('ACID')" style="background: #32ff32; color: #000;"></div>
        <div class="material-btn toggleable" onclick="selectMaterial('LAVA')" style="background: #ff4500; color: #fff;"></div>
        <div class="material-btn toggleable" onclick="selectMaterial('INCHWORM')" style="background: #ff69b4; color: #000;"></div>
        <div class="material-btn toggleable" onclick="selectMaterial('ERASER')" style="background: #000; color: #fff;"></div>
        <div class="material-btn toggleable" onclick="clearGrid()" style="background: #666; color: #fff;">â†º</div>
        <div class="material-btn toggleable" onclick="togglePause()" style="background: #666; color: #fff;">â– </div>
        <div class="material-btn toggleable" onclick="toggleSound()" style="background: #444; color: #fff;" id="soundToggle">â™ª</div>
        <div class="material-btn toggleable" onclick="decreaseBrushSize()" style="background: #333; color: #fff;">-</div>
        <div class="material-btn toggleable" id="brushSizeDisplay" style="background: #444; color: #fff;">3</div>
        <div class="material-btn toggleable" onclick="increaseBrushSize()" style="background: #333; color: #fff;">+</div>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Grid settings - dynamically sized to browser window
        const CELL_SIZE = 3;
        
        // Use visualViewport for mobile Safari compatibility
        const getViewportDimensions = () => {
            const vw = window.visualViewport ? window.visualViewport.width : window.innerWidth;
            const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
            return { width: vw, height: vh };
        };
        
        const { width: viewportWidth, height: viewportHeight } = getViewportDimensions();
        let GRID_WIDTH = Math.floor(viewportWidth / CELL_SIZE);
        let GRID_HEIGHT = Math.floor(viewportHeight / CELL_SIZE);
        
        canvas.width = GRID_WIDTH * CELL_SIZE;
        canvas.height = GRID_HEIGHT * CELL_SIZE;
        
        // Audio oscillator engine
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let master = audioCtx.createGain();
        master.gain.value = 0; // Start muted until audio unlock
        
        // Add limiter to prevent hard clipping and amplitude discontinuities
        const limiter = audioCtx.createDynamicsCompressor();
        limiter.threshold.value = -1;         // start compressing just under full-scale
        limiter.knee.value = 0;
        limiter.ratio.value = 20;
        limiter.attack.value = 0.003;
        limiter.release.value = 0.020;
        
        master.connect(limiter).connect(audioCtx.destination);

        // Water noise system - only shared resources
        const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
        const data = noiseBuffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);

        // Shared filter and gain nodes for the active water noise system
        const noiseFilter = audioCtx.createBiquadFilter();
        noiseFilter.type = 'lowpass';
        noiseFilter.frequency.value = 1400;

        const waterNoiseGain = audioCtx.createGain();
        waterNoiseGain.gain.value = 0;

        // Global crossfade gain for density-aware color control
        const crossfade = audioCtx.createGain();

        function envelope({attack=0.75, decay=0.012, sustain=1.0, release=0.05}, gain){
            const now = audioCtx.currentTime;
            gain.gain.cancelScheduledValues(now);
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(1, now + attack);
            gain.gain.linearRampToValueAtTime(sustain, now + attack + decay);
            gain.gain.setTargetAtTime(0, now + attack + decay, release);
        }

        function vibrato(osc, {freq=6, depth=7}){
            const lfo = audioCtx.createOscillator();
            lfo.frequency.value = freq;
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = depth;
            lfo.connect(lfoGain).connect(osc.frequency);
            lfo.start();
            lfo.stop(audioCtx.currentTime + 0.14);
        }

        let smoothedWaterCover = 0;
        function countWaterPixels() {
            let n = 0;
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (grid[y][x] === WATER) n++;
                }
            }
            return n;
        }

        let waterNoiseStarted = false; // track if water noise system is running
        
        function createWaterNoiseSystem() {
            // â–¸ dispose the previous nodes before building a new one
            if (currentWaterNodes) {
                try {
                    currentWaterNodes.noise.stop();
                } catch(e) {} // Ignore if already stopped
                currentWaterNodes.noise.disconnect();
                
                try {
                    currentWaterNodes.lfo.stop();
                } catch(e) {} // Ignore if already stopped
                currentWaterNodes.lfo.disconnect();
                
                try {
                    currentWaterNodes.splashLFO.stop();
                } catch(e) {} // Ignore if already stopped
                currentWaterNodes.splashLFO.disconnect();
                
                currentWaterNodes.lfoDepth.disconnect();
                currentWaterNodes.splashLFOGain.disconnect();
                currentWaterNodes.lowNoise.disconnect();
                currentWaterNodes.highNoise.disconnect();
                currentWaterNodes.surfGain.disconnect();
                currentWaterNodes.mixer.disconnect();
            }

            // Always disconnect shared filter to prevent pile-up
            try {
                noiseFilter.disconnect();
            } catch(e) {} // Ignore if already disconnected
            
            // Create new noise buffer source
            const newNoise = audioCtx.createBufferSource();
            newNoise.buffer = noiseBuffer;
            newNoise.loop = true;
            
            // Create new LFO with fresh gain node for subtle modulation
            const newLfo = audioCtx.createOscillator();
            newLfo.type = 'sine';
            newLfo.frequency.value = 0.035;
            const newLfoDepth = audioCtx.createGain();
            newLfoDepth.gain.value = 0.025; // Very subtle breathing
            
            // Create new splash LFO with fresh gain node
            const newSplashLFO = audioCtx.createOscillator();
            newSplashLFO.type = 'sine';
            newSplashLFO.frequency.value = 8;
            const newSplashLFOGain = audioCtx.createGain();
            newSplashLFOGain.gain.value = 0; // Start silent
            
            // Create fresh dual-band filters for this instance
            const newLowNoise = audioCtx.createBiquadFilter();  // 400 Hz rumble
            newLowNoise.type = 'lowpass';
            newLowNoise.frequency.value = 400;

            const newHighNoise = audioCtx.createBiquadFilter(); // 4 kHz hiss
            newHighNoise.type = 'highpass';
            newHighNoise.frequency.value = 2400;
            
            // Create surface gain for LFO modulation (separate from envelope)
            const surfGain = audioCtx.createGain();
            surfGain.gain.value = 1;
            
            // Connect everything - world state controls envelope, LFOs control texture
            newNoise.connect(noiseFilter);
            newNoise.connect(newLowNoise);
            newNoise.connect(newHighNoise);
            
            // Route dual-band through crossfade, main filter through surfGain, then combine
            newLowNoise.connect(crossfade);   // Low band to crossfade
            newHighNoise.connect(crossfade);  // High band to crossfade  
            noiseFilter.connect(surfGain);    // Main MATERIAL_TONE filter through surfGain
            
            // Create mixer for both paths
            const mixer = audioCtx.createGain();
            mixer.gain.value = 0.5; // Balance both sources
            surfGain.connect(mixer);     // Main filter path
            crossfade.connect(mixer);    // Density crossfade path
            mixer.connect(waterNoiseGain); // Combined output
            
            // Main LFO modulates surface texture, splash LFO modulates main envelope for prominence
            newLfo.connect(newLfoDepth).connect(surfGain.gain);
            newSplashLFO.connect(newSplashLFOGain).connect(waterNoiseGain.gain);
            
            // Start all
            newNoise.start();
            newLfo.start();
            newSplashLFO.start();
            
            // Store references for cleanup and control
            return { 
                noise: newNoise, 
                lfo: newLfo, 
                lfoDepth: newLfoDepth,
                splashLFO: newSplashLFO,
                splashLFOGain: newSplashLFOGain,
                lowNoise: newLowNoise,
                highNoise: newHighNoise,
                surfGain: surfGain,
                mixer: mixer
            };
        }
        
        let currentWaterNodes = null;
        let smoothedMovement = 0;
        
        function countWaterDensity() {
            // Count water pixels and their clustering density
            let totalDensity = 0;
            let waterPixelCount = 0;
            
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (grid[y][x] === WATER) {
                        waterPixelCount++;
                        // Count neighboring water pixels for density
                        let neighbors = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nx = x + dx, ny = y + dy;
                                if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                                    if (grid[ny][nx] === WATER) neighbors++;
                                }
                            }
                        }
                        totalDensity += neighbors / 8; // 0-1 density per pixel
                    }
                }
            }
            
            return { count: waterPixelCount, density: waterPixelCount > 0 ? totalDensity / waterPixelCount : 0 };
        }

        // Route MATERIAL_TONE table into filter cutoff
        const BASE_CUTOFF = 1400;              // current static value
        const TONE_TO_CUTOFF = 5;              // Hz added per MATERIAL_TONE.freq step

        function calcAmbientCutoff() {
            // scan whole grid once per Â½-second tick
            let acc = 0, cells = 0;
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const id = grid[y][x];
                    const tone = MATERIAL_TONE[id];
                    if (tone) { acc += tone.freq; cells++; }
                }
            }
            const avg = cells ? acc / cells : 0;
            return BASE_CUTOFF + avg * TONE_TO_CUTOFF;   // map 0-1100 Hz to ~cutoff
        }

        let lastWaterActivity = 0; // Track when water was last active
        
        function updateWaterNoise(falling) {
            const now = audioCtx.currentTime;
            const waterData = countWaterDensity();
            
            // Stop everything if paused, sound disabled, or no water exists
            if (isPaused || !soundEnabled || waterData.count === 0) {
                if (waterNoiseStarted) {
                    waterNoiseGain.gain.setTargetAtTime(0, now, 0.02); // Longer decay
                    // Disconnect after fade
                    setTimeout(() => {
                        if (waterNoiseStarted) {
                            waterNoiseGain.disconnect();
                            waterNoiseStarted = false;
                        }
                    }, 600);
                }
                smoothedMovement = 0;
                return;
            }
            
            // Water exists - start system if needed
            if (!waterNoiseStarted) {
                currentWaterNodes = createWaterNoiseSystem();
                waterNoiseGain.connect(master);
                waterNoiseStarted = true;
                smoothedMovement = 0; // Reset smoothed movement
                // Cancel any scheduled changes and start fresh
                waterNoiseGain.gain.cancelAndHoldAtTime(now);
                waterNoiseGain.gain.setValueAtTime(0, now);
            }
            
            // Track water activity for persistent decay
            if (falling > 0) {
                lastWaterActivity = now;
            }
            
            // Update filter cutoff based on material tones + falling water activity (once every 15 frames)
            if (treeUpdateCounter % 6 === 0) {
                const baseCutoff = calcAmbientCutoff();
                const activityBoost = Math.min(falling * 2, 800); // Up to +800Hz for high activity
                const target = baseCutoff + activityBoost;
                noiseFilter.frequency.setTargetAtTime(target, now, 0.5); // gentle slide
            }
            
            // Base ambient volume proportional to water pixel count (reduced)
            const waterCoverage = waterData.count / (GRID_WIDTH * GRID_HEIGHT);
            const ambientGain = Math.min(waterCoverage * 0.008, 0.002); // Reduced sustain
            
            // Movement creates transient bursts with decay
            const timeSinceActivity = now - lastWaterActivity;
            const activityDecay = Math.max(0, Math.exp(-timeSinceActivity * 1)); // 2s decay

            // Main volume control based on falling activity
            const targetMovement = Math.min(falling / 8, 0.01) * activityDecay;
            
            const smoothing = falling > 0 ? 0.15 : 0.5; // Faster attack, slower decay
            smoothedMovement += (targetMovement - smoothedMovement) * smoothing;
            
            // Total gain = reduced ambient + decaying movement
            const totalGain = ambientGain + smoothedMovement;
            
            // LFO depth based on water density and activity (modulates texture, not volume)
            const baseLfoDepth = waterData.density * 0.005;
            const activityLfoBoost = activityDecay * 0.003;
            const lfoDepth = baseLfoDepth + activityLfoBoost;
            
            if (currentWaterNodes && currentWaterNodes.lfoDepth) {
                currentWaterNodes.lfoDepth.gain.setTargetAtTime(lfoDepth, now, 0.3);
            }

            // Density-aware noise coloring: density 0..1 â†’ bass ratio, with falling water energy sweep
            const densityBass = 0.2 + waterData.density * 0.7;
            // Smoothly sweep toward highs when water is energetic (falling)
            const targetBass = densityBass - (smoothedMovement * 15); // Use existing smoothed movement
            crossfade.gain.setTargetAtTime(1 - Math.max(0.1, targetBass), now, 0.2); // Invert: sparse=high, dense=low
            
            // Faster transitions for more responsive feel
            const timeConstant = falling > 0 ? 0.05 : 0.5; // Quick attack, slower decay
            waterNoiseGain.gain.setTargetAtTime(totalGain, now, timeConstant);
        }

        function triggerSplashAccent(splashIntensity = 1, waterPixels = null, cueName = null) {
            const now = audioCtx.currentTime;

            // Only trigger if water noise system is running
            if (!waterNoiseStarted || !currentWaterNodes) return;

            // For splash effects, we need actual water involvement in the interaction
            // The calling code should pass waterPixels from the specific interaction
            if (waterPixels === null) {
                waterPixels = countWaterPixels();
            }
            
            if (waterPixels === 0) return; // No water = no splash
            
            const waterCoverage = waterPixels / (GRID_WIDTH * GRID_HEIGHT);
            
            // Get cue-specific modulation parameters
            let LFO_DEPTH = waterCoverage * splashIntensity * 0.008; // Base depth
            let LFO_FREQ = Math.max(3, 12 - (splashIntensity * 4)); // Base frequency
            
            // Apply audio cue modulation to noise characteristics
            if (cueName && AUDIO_CUES[cueName]) {
                const cue = AUDIO_CUES[cueName]();
                // Map cue frequency to LFO modulation
                const freqInfluence = (cue.base - 400) / 800; // Normalize around 400Hz
                LFO_FREQ = Math.max(2, LFO_FREQ + (freqInfluence * 6));
                
                // Map cue vibrato to depth modulation
                if (cue.vibrato) {
                    const vibratoInfluence = cue.vibrato.depth / 50; // Normalize vibrato depth
                    LFO_DEPTH *= (1 + vibratoInfluence * 0.5);
                }
            }
            
            if (LFO_DEPTH > 0) {
                // Use the current water nodes' splash LFO
                currentWaterNodes.splashLFO.frequency.setValueAtTime(LFO_FREQ, now);
                currentWaterNodes.splashLFOGain.gain.cancelAndHoldAtTime(now);
                currentWaterNodes.splashLFOGain.gain.linearRampToValueAtTime(LFO_DEPTH, now + 0.008);
                currentWaterNodes.splashLFOGain.gain.linearRampToValueAtTime(0, now + 0.035);
            }
        }

        const AUDIO_CUES = {
            acidFizz(){
                return {
                    base: 880,
                    env: {attack:0.001, decay:0.15, sustain:0.0, release:0.02},
                    vibrato: {freq:40, depth:80}
                };
            },
            sandClink(){
                return {
                    base: 640,
                    env: {attack:0.002, decay:0.08},
                    vibrato: {freq:5, depth:15}
                };
            },
            lavaBloop(){
                return {
                    base: 110,
                    env: {attack:0.004, decay:0.25, sustain:0.1, release:0.12},
                    vibrato: {freq:3, depth:4}
                };
            },
            waterDrop(){
                return {
                    base: 800,
                    env: {attack:0.001, decay:0.06, sustain:0.0, release:0.01},
                    vibrato: {freq:8, depth:12}
                };
            },
            steamHiss(){
                return {
                    base: 1200,
                    env: {attack:0.003, decay:0.2, sustain:0.05, release:0.1},
                    vibrato: {freq:25, depth:30}
                };
            },
            fireCrackle(){
                return {
                    base: 400,
                    env: {attack:0.002, decay:0.1, sustain:0.0, release:0.05},
                    vibrato: {freq:15, depth:20}
                };
            }
        };

        function playCue(name, detuneSemis = 0){
            if(!AUDIO_CUES[name]) return;
            const p = AUDIO_CUES[name]();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.value = p.base * Math.pow(2, detuneSemis/12);
            osc.connect(gain).connect(master);

            envelope(p.env, gain);
            if(p.vibrato) vibrato(osc, p.vibrato);

            osc.start();
            const stopTime = audioCtx.currentTime + 1;
            osc.stop(stopTime);
            
            // Cleanup nodes after stop to prevent memory leaks
            setTimeout(() => {
                osc.disconnect();
                gain.disconnect();
            }, 1100); // Slightly after stop time
        }

        // Old CA-to-Audio control system removed - now using per-worm voices

        // Old global drone system removed - now using per-worm voices

        // Audio unlock system
        let audioUnlocked = false;

        function unlockAudio() {
            if (!audioUnlocked && audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    audioUnlocked = true;
                    console.log('Audio unlocked ðŸŽµ');
                    // Fade in the master gain smoothly after unlock (only if sound enabled)
                    if (soundEnabled) {
                        const tNow = audioCtx.currentTime;
                        master.gain.linearRampToValueAtTime(0.8, tNow + 0.5); // Limiter headroom
                    }
                });
            }
        }

        // iOS/Safari audio context resume handling - background tolerant pattern
        let needsGesture = false;

        // Flag when we need a fresh user gesture to resume audio
        window.addEventListener('pageshow', () => {
            if (audioCtx && audioCtx.state !== 'running') {
                needsGesture = true;
            }
        });

        window.addEventListener('focus', () => {
            if (audioCtx && audioCtx.state !== 'running') {
                needsGesture = true;
            }
        });

        // Clean pause when page goes to background
        window.addEventListener('pagehide', () => {
            needsGesture = true;
            if (audioCtx && audioCtx.state === 'running') {
                audioCtx.suspend();
            }
        });

        // Resume audio only from genuine user gesture handlers
        ['touchstart', 'mousedown', 'keydown'].forEach(evt => {
            window.addEventListener(evt, () => {
                if (!needsGesture || !audioUnlocked) return;
                
                if (audioCtx && audioCtx.state !== 'running') {
                    // Rebuild if iOS actually closed the context
                    if (audioCtx.state === 'closed') {
                        console.log('AudioContext closed - would need rebuild');
                        return; // For now, just log this case
                    }
                    
                    audioCtx.resume().then(() => {
                        needsGesture = false;
                        console.log('AudioContext resumed from user gesture');
                        
                        // Restore master gain if sound is enabled
                        if (soundEnabled) {
                            master.gain.linearRampToValueAtTime(0.8, audioCtx.currentTime + 0.03);
                        }
                        
                        // Visual feedback
                        const soundToggle = document.getElementById('soundToggle');
                        if (soundToggle) {
                            soundToggle.style.opacity = '0.5';
                            setTimeout(() => soundToggle.style.opacity = '1', 500);
                        }
                    }).catch(err => console.warn('AudioContext resume() failed', err));
                }
            }, { passive: true });
        });

        // Start with audio muted until unlocked
        master.gain.value = 0;
        
        // Material types
        const EMPTY = 0;
        const SAND = 1;
        const WATER = 2;
        const FIRE = 3;
        const DIRT = 4;
        const TREE = 5;
        const GLASS = 6;
        const STEAM = 7;
        const ACID = 8;
        const ERASER = 9;
        const DEAD_TREE = 10;
        const LAVA = 11;
        const INCHWORM = 12;
        const INCHWORM_HEAD = 13;
        const INCHWORM_BODY = 14;
        
        // Current selected material
        let selectedMaterial = SAND;
        let brushSize = 3;
        
        // Material properties
        const materials = {
            [EMPTY]: { density: 0, flammable: false, liquid: false },
            [SAND]: { density: 3, flammable: false, liquid: false },
            [WATER]: { density: 2, flammable: false, liquid: true },
            [FIRE]: { density: 1, flammable: false, liquid: false, life: 60 },
            [DIRT]: { density: 4, flammable: false, liquid: false },
            [TREE]: { density: 5, flammable: true, liquid: false },
            [GLASS]: { density: 8, flammable: false, liquid: false },
            [STEAM]: { density: 0.5, flammable: false, liquid: false, life: 120 },
            [ACID]: { density: 2.5, flammable: false, liquid: true, life: 90 },
            [ERASER]: { density: 1, flammable: false, liquid: false },
            [DEAD_TREE]: { density: 5, flammable: true, liquid: false },
            [LAVA]: { density: 4, flammable: false, liquid: true },
            [INCHWORM]: { density: 1, flammable: true, liquid: false, life: 300 },
            [INCHWORM_HEAD]: { density: 1, flammable: true, liquid: false, life: 300 },
            [INCHWORM_BODY]: { density: 1, flammable: true, liquid: false, life: 300 }
        };
        
        // Colors for each material
        const materialColors = {
            [EMPTY]: [[0, 0, 0, 255]],
            [SAND]: [
                [220, 184, 112, 255],
                [210, 174, 102, 255],
                [200, 164, 92, 255],
                [190, 154, 82, 255]
            ],
            [WATER]: [
                [74, 144, 226, 255],
                [64, 134, 216, 255],
                [84, 154, 236, 255],
                [54, 124, 206, 255]
            ],
            [FIRE]: [
                [255, 107, 53, 255],
                [255, 140, 0, 255],
                [255, 69, 0, 255],
                [255, 165, 0, 255]
            ],
            [DIRT]: [
                [139, 69, 19, 255],
                [160, 82, 45, 255],
                [101, 67, 33, 255],
                [120, 75, 25, 255]
            ],
            [TREE]: [
                [34, 139, 34, 255],
                [46, 125, 50, 255],
                [56, 142, 60, 255],
                [27, 94, 32, 255]
            ],
            [GLASS]: [
                [180, 220, 240, 200],
                [170, 210, 230, 200],
                [190, 230, 250, 200],
                [160, 200, 220, 200]
            ],
            [STEAM]: [
                [240, 240, 240, 150],
                [230, 230, 230, 140],
                [250, 250, 250, 160],
                [220, 220, 220, 130]
            ],
            [ACID]: [
                [50, 255, 50, 255],
                [40, 245, 40, 255],
                [60, 255, 60, 255],
                [30, 235, 30, 255]
            ],
            [ERASER]: [
                [255, 100, 255, 255],
                [245, 90, 245, 255],
                [255, 110, 255, 255],
                [235, 80, 235, 255]
            ],
            [DEAD_TREE]: [
                [101, 67, 33, 255],
                [120, 75, 25, 255],
                [90, 60, 30, 255],
                [110, 70, 35, 255]
            ],
            [LAVA]: [
                [255, 69, 0, 255],
                [255, 140, 0, 255], 
                [255, 99, 71, 255],
                [220, 20, 60, 255]
            ],
            [INCHWORM]: [
                [255, 182, 193, 255], // Light pink
                [255, 105, 180, 255], // Hot pink
                [255, 20, 147, 255],  // Deep pink
                [255, 192, 203, 255]  // Pink
            ],
            [INCHWORM_HEAD]: [
                [199, 21, 133, 255],  // Medium violet red (darker pink for head)
                [219, 112, 147, 255], // Pale violet red
                [208, 32, 144, 255],  // Violet red
                [186, 85, 211, 255]   // Medium orchid
            ],
            [INCHWORM_BODY]: [
                [255, 20, 147, 255],  // Deep pink (bright pink for body)
                [255, 105, 180, 255], // Hot pink
                [255, 182, 193, 255], // Light pink
                [255, 160, 122, 255]  // Light salmon pink
            ]
        };

        // Material tone lookup for worm voice modulation
        const MATERIAL_TONE = {
            [SAND]:  {freq: 220,  depth:  4},
            [WATER]: {freq: 330,  depth: 12},
            [FIRE]:  {freq: 660,  depth: 25},
            [DIRT]:  {freq: 110,  depth:  6},
            [TREE]:  {freq: 175,  depth:  8},
            [GLASS]: {freq: 440,  depth: 10},
            [STEAM]: {freq: 990,  depth: 14},
            [ACID]:  {freq: 555,  depth: 18},
            [LAVA]:  {freq: 120,  depth: 22}
        };

        // Voice allocation system - max 24 voices to prevent crashes
        let allocatedVoices = [];
        const MAX_SYNTH_VOICES = 16; // Balanced for performance vs richness
        
        function attachAudioVoice(worm) {
            // Check if we've hit the voice limit (but allow upgrading silent worms)
            if (allocatedVoices.length >= MAX_SYNTH_VOICES && 
                (!worm.voice || worm.voice.hasVoice === true)) {
                // No voice allocated - worm will be silent
                worm.voice = {
                    baseFreq: 160 + (worm.id % 8) * 25,
                    lastMaterial: EMPTY,
                    id: worm.id,
                    isActive: false,
                    hasVoice: false
                };
                return;
            }
            
            // Create persistent FM voice for this worm
            const baseFreq = 160 + (worm.id % 8) * 25; // Slight pitch variation per worm
            
            // Dual carrier FM synthesis
            const carrier1 = audioCtx.createOscillator();
            const carrier1Gain = audioCtx.createGain();
            const carrier2 = audioCtx.createOscillator();
            const carrier2Gain = audioCtx.createGain();
            
            // Modulator oscillator (for FM)
            const modulator = audioCtx.createOscillator();
            const mod1Gain = audioCtx.createGain();
            const mod2Gain = audioCtx.createGain();
            
            // Voice envelope gain
            const voiceGain = audioCtx.createGain();
            
            // Event envelope and amplifier
            const eventEnv = audioCtx.createGain();
            const eventAmp = audioCtx.createGain();
            
            carrier1.type = 'sine';
            carrier2.type = 'sine';
            modulator.type = 'sine';
            // Fixed carrier frequencies (never change during FM)
            carrier1.frequency.value = baseFreq;
            carrier2.frequency.value = baseFreq * 1.5; // Perfect fifth
            modulator.frequency.value = baseFreq * 2; // 2:1 ratio
            
            // Initialize detune parameters for FM (in cents)
            carrier1.detune.value = 0;
            carrier2.detune.value = 0;
            
            // Start silent
            carrier1Gain.gain.value = 0.12; // Primary carrier
            carrier2Gain.gain.value = 0; // Secondary carrier (silent until events)
            mod1Gain.gain.value = 0; // No modulation until triggered
            mod2Gain.gain.value = 0; // No modulation until triggered
            voiceGain.gain.value = 0; // Start silent
            eventEnv.gain.value = 0; // Event envelope starts silent
            eventAmp.gain.value = 1; // Event amplifier unity gain
            
            // FM routing: modulator drives detune (cents) to avoid 0Hz crossings
            modulator.connect(mod1Gain).connect(carrier1.detune);
            modulator.connect(mod2Gain).connect(carrier2.detune);
            carrier1.connect(carrier1Gain).connect(voiceGain);
            carrier2.connect(carrier2Gain).connect(voiceGain);
            
            // Dual path: voiceGain for movement, eventEnv for events
            voiceGain.connect(master); // Movement path
            voiceGain.connect(eventEnv).connect(eventAmp).connect(master); // Event path
            
            carrier1.start();
            carrier2.start();
            modulator.start();
            
            worm.voice = {
                baseFreq,
                carrier1,
                carrier2,
                modulator,
                carrier1Gain,
                carrier2Gain,
                mod1Gain,
                mod2Gain,
                voiceGain,
                eventEnv,
                eventAmp,
                lastMaterial: EMPTY,
                id: worm.id,
                isActive: false,
                hasVoice: true
            };
            
            // Add to allocated voices tracking
            allocatedVoices.push(worm);
        }

        // Movement audio throttling
        let movementAudioCounter = 0;
        
        function playWormMovement(worm, moveData) {
            if (!worm.voice || !worm.voice.hasVoice) return;
            
            // Throttle: only play movement audio every 4th frame
            movementAudioCounter++;
            if (movementAudioCounter % 4 !== 0) return;
            
            const v = worm.voice;
            const now = audioCtx.currentTime;
            
            // Calculate mood-based modulation from memories
            const mood = worm.memory.reduce((s, m) => s + m.weight, 0) / Math.max(worm.memory.length, 1);
            const modRate = Math.max(1, Math.min(6, 2 + mood * 2)); // 1-6 Hz mod rate
            
            // Movement direction affects carrier frequency
            const moveVector = Math.sqrt(moveData.dx * moveData.dx + moveData.dy * moveData.dy);
            const carrierFreq = v.baseFreq * (1 + moveVector * 0.1);
            const modFreq = carrierFreq * modRate;
            
            // Update oscillator frequencies - only carrier1 for movement (with smoothing)
            v.carrier1.frequency.cancelScheduledValues(now);
            v.carrier1.frequency.setValueAtTime(v.carrier1.frequency.value, now);
            v.carrier1.frequency.linearRampToValueAtTime(carrierFreq, now + 0.05); // Slower for smoothness
            
            v.modulator.frequency.cancelScheduledValues(now);
            v.modulator.frequency.setValueAtTime(v.modulator.frequency.value, now);
            v.modulator.frequency.linearRampToValueAtTime(modFreq, now + 0.05); // Slower for smoothness
            
            // Movement intensity affects volume and modulation depth
            const intensity = Math.abs(moveData.dx) + Math.abs(moveData.dy);
            const gain = 0.03 * intensity;
            const modDepth = Math.abs(mood) * 15 + 3; // 3-18 Hz FM depth (reduced)
            
            // Trigger voice envelope
            v.voiceGain.gain.cancelScheduledValues(now);
            v.voiceGain.gain.setValueAtTime(v.voiceGain.gain.value, now);
            v.voiceGain.gain.linearRampToValueAtTime(gain, now + 0.01);
            v.voiceGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            
            // Movement uses only carrier1 modulation (with smoothing)
            v.mod1Gain.gain.cancelScheduledValues(now);
            v.mod1Gain.gain.setValueAtTime(v.mod1Gain.gain.value, now); // Start from current value
            v.mod1Gain.gain.linearRampToValueAtTime(modDepth, now + 0.04); // Slower ramp
            v.mod1Gain.gain.exponentialRampToValueAtTime(0.1, now + 0.15);
            
            // Keep carrier2 silent for movement (smooth)
            smoothSet(v.carrier2Gain.gain, 0, now);
            
            v.isActive = true;
        }

        // Reallocate freed voice slots to existing silent worms
        function reallocateVoiceToSilentWorm() {
            // Only proceed if we have available voice slots
            if (allocatedVoices.length >= MAX_SYNTH_VOICES) return;
            
            // Find silent worms (those with hasVoice: false)
            const silentWorms = wormList.filter(worm => 
                worm.voice && !worm.voice.hasVoice
            );
            
            if (silentWorms.length === 0) return;
            
            // Prioritize older worms (they've been waiting longer)
            silentWorms.sort((a, b) => a.id - b.id); // Lower ID = older worm
            
            // Give voice to the oldest silent worm
            const selectedWorm = silentWorms[0];
            
            // Upgrade the silent worm to have a real voice
            attachAudioVoice(selectedWorm);
            
            console.log(`Voice reallocated to worm ${selectedWorm.id}`);
        }

        // Helper to avoid amplitude discontinuities on any parameter change
        function smoothSet(param, value, t, ramp = 0.002) {
            param.cancelAndHoldAtTime(t);                      // hold current value
            param.linearRampToValueAtTime(value, t + ramp);    // tiny cross-fade
        }

        function playWormEvent(worm, eventType) {
            if (!worm.voice || !worm.voice.hasVoice) return;
            
            const v = worm.voice;
            const now = audioCtx.currentTime;
            
            // Calculate mood-based frequency with Lydian intervals based on memory
            const mood = worm.memory.reduce((s, m) => s + m.weight, 0) / 5;
            const lydianIntervals = [1, 9/8, 5/4, 11/8]; // Lydian mode intervals
            const intervalIndex = Math.floor(Math.abs(mood * 4)) % 4;
            const lydianMultiplier = lydianIntervals[intervalIndex];
            const semis = Math.max(-12, Math.min(12, mood * 3));
            const moodFreq = v.baseFreq * lydianMultiplier * Math.pow(2, semis / 12);
            
            if (eventType === 'mating') {
                // Mating: Add second carrier with cross-modulation
                const freq1 = moodFreq * 1.2; // Slightly higher
                const freq2 = moodFreq * 1.5; // Perfect fifth
                const modFreq = moodFreq * 3; // Higher modulation rate
                
                // Update detune smoothly for mating (in cents to avoid 0Hz crossings)
                const detune1 = 1200 * Math.log2(freq1 / v.baseFreq); // Convert freq ratio to cents
                const detune2 = 1200 * Math.log2(freq2 / v.baseFreq);
                const modDetune = 1200 * Math.log2(modFreq / (v.baseFreq * 2));
                
                v.carrier1.detune.cancelAndHoldAtTime(now);
                v.carrier1.detune.linearRampToValueAtTime(detune1, now + 0.03);
                
                v.carrier2.detune.cancelAndHoldAtTime(now);
                v.carrier2.detune.linearRampToValueAtTime(detune2, now + 0.03);
                
                v.modulator.detune.cancelAndHoldAtTime(now);
                v.modulator.detune.linearRampToValueAtTime(modDetune, now + 0.03);
                
                // Activate both carriers with controlled volume (smooth ramps)
                const tgtTime = now + 0.010;
                v.carrier1Gain.gain.cancelAndHoldAtTime(now);
                v.carrier1Gain.gain.linearRampToValueAtTime(0.06, tgtTime);
                
                v.carrier2Gain.gain.cancelAndHoldAtTime(now);
                v.carrier2Gain.gain.linearRampToValueAtTime(0.05, tgtTime);
                
                // Cross-modulation: different depths for each carrier (with smoothing) - adjusted for cents
                v.mod1Gain.gain.cancelAndHoldAtTime(now);
                v.mod1Gain.gain.linearRampToValueAtTime(150, now + 0.05); // Scaled up for cents (was 20)
                
                v.mod2Gain.gain.cancelAndHoldAtTime(now);
                v.mod2Gain.gain.linearRampToValueAtTime(200, now + 0.05); // Scaled up for cents (was 30)
                
                // Event envelope - short and punchy with controlled volume (smooth ramp)
                v.eventAmp.gain.cancelAndHoldAtTime(now);
                v.eventAmp.gain.linearRampToValueAtTime(0.18, now + 0.003); // 3ms ramp for events (further reduced)
                // Pop-safe envelope reset and attack
                smoothSet(v.eventEnv.gain, 0, now);                   // pop-safe reset
                v.eventEnv.gain.linearRampToValueAtTime(1, now + 0.004); // Fast attack
                v.eventEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.08); // Short duration
                smoothSet(v.eventEnv.gain, 0, now + 0.08);            // return to 0 smoothly
                smoothSet(v.eventAmp.gain, 0.02, now + 0.10);         // fade eventAmp back down
                
                // Fade modulation to match envelope
                v.mod1Gain.gain.exponentialRampToValueAtTime(0.1, now + 0.08);
                v.mod2Gain.gain.exponentialRampToValueAtTime(0.1, now + 0.08);
                v.carrier2Gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                
            } else if (eventType === 'eating') {
                // Eating: Add second carrier with parallel modulation  
                const freq1 = moodFreq * 0.8; // Lower, satisfied
                const freq2 = moodFreq * 0.6; // Even lower harmonic
                const modFreq = moodFreq * 1.5; // Moderate modulation
                
                // Update detune smoothly for eating (in cents to avoid 0Hz crossings)
                const detune1 = 1200 * Math.log2(freq1 / v.baseFreq); // Convert freq ratio to cents
                const detune2 = 1200 * Math.log2(freq2 / v.baseFreq);
                const modDetune = 1200 * Math.log2(modFreq / (v.baseFreq * 2));
                
                v.carrier1.detune.cancelAndHoldAtTime(now);
                v.carrier1.detune.linearRampToValueAtTime(detune1, now + 0.03);
                
                v.carrier2.detune.cancelAndHoldAtTime(now);
                v.carrier2.detune.linearRampToValueAtTime(detune2, now + 0.03);
                
                v.modulator.detune.cancelAndHoldAtTime(now);
                v.modulator.detune.linearRampToValueAtTime(modDetune, now + 0.03);
                
                // Activate both carriers with controlled volume (smooth ramps)
                const tgtTime2 = now + 0.010;
                v.carrier1Gain.gain.cancelAndHoldAtTime(now);
                v.carrier1Gain.gain.linearRampToValueAtTime(0.05, tgtTime2);
                
                v.carrier2Gain.gain.cancelAndHoldAtTime(now);
                v.carrier2Gain.gain.linearRampToValueAtTime(0.06, tgtTime2); // Lower carrier louder
                
                // Parallel modulation: similar depths (with smoothing) - adjusted for cents
                v.mod1Gain.gain.cancelAndHoldAtTime(now);
                v.mod1Gain.gain.linearRampToValueAtTime(100, now + 0.05); // Scaled up for cents (was 12)
                
                v.mod2Gain.gain.cancelAndHoldAtTime(now);
                v.mod2Gain.gain.linearRampToValueAtTime(120, now + 0.05); // Scaled up for cents (was 15)
                
                // Event envelope for eating - slightly longer than mating with controlled volume (smooth ramp)
                v.eventAmp.gain.cancelAndHoldAtTime(now);
                v.eventAmp.gain.linearRampToValueAtTime(0.15, now + 0.003); // 3ms ramp for eating (further reduced)
                // Pop-safe envelope reset and attack for eating
                smoothSet(v.eventEnv.gain, 0, now);                   // pop-safe reset
                v.eventEnv.gain.linearRampToValueAtTime(1, now + 0.007); // Slower attack
                v.eventEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.12); // Slightly longer
                smoothSet(v.eventEnv.gain, 0, now + 0.12);            // return to 0 smoothly
                smoothSet(v.eventAmp.gain, 0.02, now + 0.14);         // fade eventAmp back down
                
                // Fade modulation to match envelope  
                v.mod1Gain.gain.exponentialRampToValueAtTime(0.1, now + 0.12);
                v.mod2Gain.gain.exponentialRampToValueAtTime(0.1, now + 0.12);
                v.carrier2Gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                
            } else {
                // Dying/Material: Simple single carrier events
                let freqMod = 1;
                let ampLevel = 0.06;
                let attack = 0.01;
                let duration = 0.06;
                let modDepth = 8;
                
                if (eventType === 'dying') {
                    freqMod = 0.5;
                    ampLevel = 0.1; // Reduced headroom
                    attack = 0.02;
                    duration = 0.4; // Much shorter than before (was 2.0)
                    modDepth = 3;
                } else if (eventType === 'material') {
                    freqMod = 1.0;
                    ampLevel = 0.06; // Reduced headroom
                    attack = 0.001;
                    duration = 0.04; // Very short blip
                    modDepth = 5;
                }
                
                const targetFreq = moodFreq * freqMod;
                const modFreq = targetFreq * 2;
                
                // Single carrier operation with smooth detune changes (in cents)
                const detune1 = 1200 * Math.log2(targetFreq / v.baseFreq);
                const modDetune = 1200 * Math.log2(modFreq / (v.baseFreq * 2));
                
                v.carrier1.detune.cancelAndHoldAtTime(now);
                v.carrier1.detune.linearRampToValueAtTime(detune1, now + 0.03);
                
                v.modulator.detune.cancelAndHoldAtTime(now);
                v.modulator.detune.linearRampToValueAtTime(modDetune, now + 0.03);
                smoothSet(v.carrier2Gain.gain, 0, now); // Keep carrier2 silent (smooth)
                
                // Event envelope for dying/material (smooth ramp)
                v.eventAmp.gain.cancelAndHoldAtTime(now);
                v.eventAmp.gain.linearRampToValueAtTime(ampLevel, now + 0.003); // 3ms ramp
                // Pop-safe envelope reset and attack for dying/material
                smoothSet(v.eventEnv.gain, 0, now);                   // pop-safe reset
                v.eventEnv.gain.linearRampToValueAtTime(1, now + attack + 0.002); // attack with safety buffer
                v.eventEnv.gain.exponentialRampToValueAtTime(0.001, now + duration);
                smoothSet(v.eventEnv.gain, 0, now + duration);        // return to 0 smoothly
                smoothSet(v.eventAmp.gain, 0.02, now + duration + 0.02); // fade eventAmp back down
                
                // Smooth modulation for single carrier events - adjusted for cents
                const centsModDepth = modDepth * 8; // Scale up for cents (3â†’24, 5â†’40)
                v.mod1Gain.gain.cancelAndHoldAtTime(now);
                v.mod1Gain.gain.linearRampToValueAtTime(centsModDepth, now + 0.04); // Slower ramp
                v.mod1Gain.gain.exponentialRampToValueAtTime(0.001, now + duration); // Fixed: was 0.1, now 0.001
            }
            
            v.isActive = true;
        }
        
        // Grid and image data
        let grid, fireLifeGrid, steamLifeGrid, acidLifeGrid, lavaLifeGrid, inchwormLifeGrid, waterTintGrid, imageData;
        let gridA, gridB, fireLifeGridA, fireLifeGridB, steamLifeGridA, steamLifeGridB;
        let acidLifeGridA, acidLifeGridB, lavaLifeGridA, lavaLifeGridB, inchwormLifeGridA, inchwormLifeGridB;
        let waterTintGridA, waterTintGridB;
        let currentGridSet = 'A'; // Toggle between A and B grid sets
        let treeGrowthQueue = []; // Queue for tree growth patterns
        let treeDecompositionGrid; // Grid to track decomposing trees
        let wormList = []; // Track all 3-pixel worms
        let nextWormId = 1;
        let colorCache; // Cache for consistent material colors per position
        let tempCanvas, tempCtx; // Reusable canvas for rendering
        let treeUpdateCounter = 0; // Counter for tree updates
        let generators = []; // Array to store generator positions and materials
        
        function initializeGrids() {
            // Create double buffer grid sets
            gridA = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(EMPTY));
            gridB = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(EMPTY));
            fireLifeGridA = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            fireLifeGridB = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            steamLifeGridA = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            steamLifeGridB = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            acidLifeGridA = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            acidLifeGridB = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            lavaLifeGridA = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            lavaLifeGridB = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            inchwormLifeGridA = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            inchwormLifeGridB = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            waterTintGridA = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            waterTintGridB = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            
            treeDecompositionGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            colorCache = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(null));
            
            // Initialize current grids to A set
            grid = gridA;
            fireLifeGrid = fireLifeGridA;
            steamLifeGrid = steamLifeGridA;
            acidLifeGrid = acidLifeGridA;
            lavaLifeGrid = lavaLifeGridA;
            inchwormLifeGrid = inchwormLifeGridA;
            waterTintGrid = waterTintGridA;
            
            // Create reusable canvas for rendering
            tempCanvas = document.createElement('canvas');
            tempCanvas.width = GRID_WIDTH;
            tempCanvas.height = GRID_HEIGHT;
            tempCtx = tempCanvas.getContext('2d');
            
            imageData = ctx.createImageData(GRID_WIDTH, GRID_HEIGHT);
        }
        
        initializeGrids();
        
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let isPaused = false;
        let soundEnabled = true;
        
        function getRandomColor(material) {
            const colors = materialColors[material];
            return colors[0]; // Use first color consistently
        }
        
        function getWormColor(material, x, y) {
            // Find which worm this pixel belongs to
            const worm = wormList.find(w => 
                (w.head.x === x && w.head.y === y) ||
                (w.body.x === x && w.body.y === y) ||
                (w.tail.x === x && w.tail.y === y)
            );
            
            if (worm && worm.colors) {
                // Use the worm's individual genetic colors
                const partName = (() => {
                    if (worm.head.x === x && worm.head.y === y) return 'head';
                    if (worm.body.x === x && worm.body.y === y) return 'body';
                    if (worm.tail.x === x && worm.tail.y === y) return 'tail';
                    return 'tail';
                })();
                
                // Pick a variant that's stable for this pixel but differs across worms
                const colorVariants = worm.colors[partName];
                const idx = worm.id & 3;   // 0-3 stable per worm
                return colorVariants[idx];
            }
            
            // Fallback to default material colors
            return getRandomColor(material);
        }

        function getPixelColor(material, x, y) {
            // For worm pixels, ALWAYS use individual worm colors (no caching)
            if (material === INCHWORM || material === INCHWORM_HEAD || material === INCHWORM_BODY) {
                return getWormColor(material, x, y);
            }
            
            // For non-worm materials, use caching as before
            if (colorCache[y][x] && colorCache[y][x].material === material) {
                return colorCache[y][x].color;
            }
            
            // Generate new random color for new pixel and cache it
            const color = getRandomColor(material);
            colorCache[y][x] = { material, color };
            return color;
        }
        
        function clearColorCache(x, y) {
            if (colorCache && colorCache[y] && colorCache[y][x]) {
                colorCache[y][x] = null;
            }
        }
        
        function selectMaterial(materialName) {
            const materialMap = { SAND, WATER, FIRE, DIRT, TREE, GLASS, STEAM, ACID, ERASER, DEAD_TREE, LAVA, INCHWORM };
            selectedMaterial = materialMap[materialName];
            
            // Update UI
            document.querySelectorAll('.material-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');
        }
        
        function getGridPos(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((clientX - rect.left) / CELL_SIZE);
            const y = Math.floor((clientY - rect.top) / CELL_SIZE);
            return { x, y };
        }
        
        function isValidPos(x, y) {
            return x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT;
        }
        
        function canPlaceTree(x, y, gridRef = grid) {
            if (!isValidPos(x, y) || gridRef[y][x] !== EMPTY) {
                return false;
            }
            return true;
        }
        
        
        function addMaterial(x, y, material, radius = 3) {
            // Special handling for worm spawning
            if (material === INCHWORM) {
                spawnSingleWorm(x, y);
                return;
            }
            
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (isValidPos(nx, ny) && Math.sqrt(dx*dx + dy*dy) <= radius) {
                        if ((grid[ny][nx] === EMPTY || material === ERASER) && Math.random() < 0.2) {
                            if (material === ERASER) {
                                // Eraser removes whatever is there
                                grid[ny][nx] = EMPTY;
                                fireLifeGrid[ny][nx] = 0;
                                steamLifeGrid[ny][nx] = 0;
                                acidLifeGrid[ny][nx] = 0;
                                lavaLifeGrid[ny][nx] = 0;
                                inchwormLifeGrid[ny][nx] = 0;
                                treeDecompositionGrid[ny][nx] = 0;
                            } else {
                                grid[ny][nx] = material;
                                if (material === FIRE) {
                                    fireLifeGrid[ny][nx] = materials[FIRE].life;
                                } else if (material === STEAM) {
                                    steamLifeGrid[ny][nx] = materials[STEAM].life;
                                } else if (material === ACID) {
                                    acidLifeGrid[ny][nx] = materials[ACID].life;
                                } else if (material === DEAD_TREE) {
                                    treeDecompositionGrid[ny][nx] = 180; // Start decomposition timer
                                }
                            }
                        }
                    }
                }
            }
        }
        
        function spawnSingleWorm(centerX, centerY) {
            // Find empty spaces around the click position for a single worm
            const spawnCandidates = [];
            
            // Check 5x5 area around click position
            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    const x = centerX + dx;
                    const y = centerY + dy;
                    
                    if (isValidPos(x, y) && grid[y][x] === EMPTY) {
                        // Check if this position has surface contact
                        if (hasValidSurface(x, y)) {
                            spawnCandidates.push({ x, y });
                        }
                    }
                }
            }
            
            // Spawn worm if enough empty spaces with surface contact
            if (spawnCandidates.length >= 3) {
                spawnThreePixelWorm(spawnCandidates, grid, inchwormLifeGrid);
            }
        }

        function spawnThreePixelWormWithMemory(spawnCandidates, grid, lifeGrid, parent1, parent2) {
            // Shuffle candidates to pick random positions
            const shuffled = [...spawnCandidates];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            
            // Try to find 3 connected positions
            for (let i = 0; i < shuffled.length - 2; i++) {
                const head = shuffled[i];
                
                // Find positions adjacent to head for body
                const bodyOptions = shuffled.filter(pos => 
                    Math.abs(pos.x - head.x) <= 1 && Math.abs(pos.y - head.y) <= 1 && 
                    !(pos.x === head.x && pos.y === head.y)
                );
                
                if (bodyOptions.length > 0) {
                    const body = bodyOptions[0];
                    
                    // Find positions adjacent to body for tail
                    const tailOptions = shuffled.filter(pos => 
                        Math.abs(pos.x - body.x) <= 1 && Math.abs(pos.y - body.y) <= 1 && 
                        !(pos.x === head.x && pos.y === head.y) && 
                        !(pos.x === body.x && pos.y === body.y)
                    );
                    
                    if (tailOptions.length > 0) {
                        const tail = tailOptions[0];
                        
                        // Create the worm with inherited memory
                        const wormId = nextWormId++;
                        const defaultColors = {
                            tail: materialColors[INCHWORM].map(c => [...c]),
                            head: materialColors[INCHWORM_HEAD].map(c => [...c]),
                            body: materialColors[INCHWORM_BODY].map(c => [...c])
                        };
                        const worm = {
                            id: wormId,
                            head: { x: head.x, y: head.y },
                            body: { x: body.x, y: body.y },
                            tail: { x: tail.x, y: tail.y },
                            life: materials[INCHWORM].life,
                            direction: { x: 0, y: 0 },
                            memory: inheritMemory(parent1, parent2),
                            currentGoal: null,
                            blockedCounter: 0,
                            colors: defaultColors,
                            wasOnWater: false,
                            underHead: EMPTY
                        };
                        
                        wormList.push(worm);
                        attachAudioVoice(worm);
                        
                        // Place worm pixels
                        grid[head.y][head.x] = INCHWORM_HEAD;
                        grid[body.y][body.x] = INCHWORM_BODY;
                        grid[tail.y][tail.x] = INCHWORM;
                        
                        lifeGrid[head.y][head.x] = worm.life;
                        lifeGrid[body.y][body.x] = worm.life;
                        lifeGrid[tail.y][tail.x] = worm.life;
                        
                        break;
                    }
                }
            }
        }

        function calculateColorGenetics(parent1, parent2) {
            // Calculate color inheritance based on memory pattern differences
            const p1MemorySum = parent1.memory.reduce((sum, mem) => sum + mem.weight, 0);
            const p2MemorySum = parent2.memory.reduce((sum, mem) => sum + mem.weight, 0);
            
            // Calculate memory diversity (how varied their experiences are)
            const p1Diversity = parent1.memory.length > 0 ? 
                Math.abs(Math.max(...parent1.memory.map(m => m.weight)) - Math.min(...parent1.memory.map(m => m.weight))) : 0;
            const p2Diversity = parent2.memory.length > 0 ? 
                Math.abs(Math.max(...parent2.memory.map(m => m.weight)) - Math.min(...parent2.memory.map(m => m.weight))) : 0;
            
            // Color inheritance ratios based on memory strength and diversity
            const totalMemory = Math.abs(p1MemorySum) + Math.abs(p2MemorySum) + 1;
            const p1Influence = Math.abs(p1MemorySum) / totalMemory;
            const p2Influence = Math.abs(p2MemorySum) / totalMemory;
            
            // Mutation chance based on memory diversity difference
            const diversityDiff = Math.abs(p1Diversity - p2Diversity);
            const mutationChance = Math.min(0.3, diversityDiff * 0.05); // Max 30% mutation chance
            
            return {
                parent1Influence: p1Influence,
                parent2Influence: p2Influence,
                mutationChance: mutationChance
            };
        }
        
        function generateOffspringColors(parent1, parent2, genetics, inheritedMemory) {
            // Generate unique colors for offspring based on genetic mixing and memory inheritance
            // Start from parent colors if available, not global material colors
            const baseColors = {
                tail: parent1.colors ? parent1.colors.tail : materialColors[INCHWORM],
                head: parent1.colors ? parent1.colors.head : materialColors[INCHWORM_HEAD], 
                body: parent1.colors ? parent1.colors.body : materialColors[INCHWORM_BODY]
            };
            
            // Calculate brightness modifier based on inherited memory quality
            const memoryWeightSum = inheritedMemory.reduce((sum, mem) => sum + mem.weight, 0);
            const avgMemoryWeight = inheritedMemory.length > 0 ? memoryWeightSum / inheritedMemory.length : 0;
            
            // If no meaningful memories, use parent memory summary for color inheritance
            let actualAvgWeight = avgMemoryWeight;
            if (inheritedMemory.length === 0) {
                const p1Sum = parent1.memory.reduce((sum, mem) => sum + mem.weight, 0);
                const p2Sum = parent2.memory.reduce((sum, mem) => sum + mem.weight, 0);
                const totalParentMemories = parent1.memory.length + parent2.memory.length;
                actualAvgWeight = totalParentMemories > 0 ? (p1Sum + p2Sum) / totalParentMemories : 0;
            }
            
            // Calculate hue bias based on food vs breeding success
            const foodPos = inheritedMemory.filter(m => m.kind === 'food' && m.weight > 0)
                                          .reduce((s, m) => s + m.weight, 0);
            const breedPos = inheritedMemory.filter(m => m.kind === 'breed' && m.weight > 0)
                                           .reduce((s, m) => s + m.weight, 0);
            const totalPos = foodPos + breedPos + 1e-6; // avoid division by zero
            const hueBias = (foodPos - breedPos) / totalPos; // +1 => all food, -1 => all breeding
            
            // Brightness adjustment: positive memories = lighter, negative = darker
            // Increased sensitivity for more visible inheritance
            let brightnessModifier = actualAvgWeight * 0.4; // Increased from 0.15 to 0.4
            
            // Force visible brightness shifts for inheritance
            if (Math.abs(brightnessModifier) < 0.15) {
                brightnessModifier = 0.15 * Math.sign(brightnessModifier || (Math.random()<0.5?1:-1));
            }
            
            // Cap at reasonable limits
            brightnessModifier = Math.max(-0.6, Math.min(0.6, brightnessModifier));
            
            // Define hue tint palettes
            const foodTint = [255, 195, 145];   // warmer, peachy-pink
            const breedTint = [200, 120, 255];  // cooler, lilac-pink
            const neutralTint = [255, 182, 193]; // standard light pink
            
            // Blend tints based on hue bias
            const blendTints = (tint1, tint2, bias) => {
                const absB = Math.abs(bias);
                return bias >= 0 
                    ? tint1.map((v, i) => Math.round(v * absB + tint2[i] * (1 - absB)))
                    : tint2.map((v, i) => Math.round(v * absB + tint1[i] * (1 - absB)));
            };
            
            const baseTint = blendTints(foodTint, breedTint, hueBias);
            
            const offspringColors = {
                tail: [],
                head: [],
                body: []
            };
            
            // For each body part, create color variants by blending parents
            for (const [part, baseColorArray] of Object.entries(baseColors)) {
                for (let i = 0; i < 4; i++) {
                    const p1Color = (parent1.colors ?? baseColors)[part][i];
                    const p2Color = (parent2.colors ?? baseColors)[part][i];
                    
                    let color = [0, 0, 0, 255];
                    // Blend parent colors based on memory influence
                    for (let c = 0; c < 3; c++) { // RGB channels
                        color[c] = Math.round(
                            p1Color[c] * genetics.parent1Influence + 
                            p2Color[c] * genetics.parent2Influence
                        );
                    }
                    
                    // Apply hue tint based on food vs breeding bias
                    for (let c = 0; c < 3; c++) {
                        color[c] = Math.round(color[c] * 0.7 + baseTint[c] * 0.3); // 30% tint influence
                    }
                    
                    // Apply brightness adjustment based on inherited memory patterns
                    for (let c = 0; c < 3; c++) { // RGB channels
                        if (brightnessModifier >= 0) {
                            // Lighten: move toward white (255)
                            color[c] = Math.round(color[c] + (255 - color[c]) * brightnessModifier);
                        } else {
                            // Darken: move toward black (0)
                            color[c] = Math.round(color[c] * (1 + brightnessModifier));
                        }
                        color[c] = Math.max(0, Math.min(255, color[c]));
                    }
                    
                    // Apply mutations based on memory diversity (smaller now that we have brightness)
                    if (Math.random() < genetics.mutationChance) {
                        // Mutate each RGB channel slightly
                        for (let c = 0; c < 3; c++) {
                            const mutation = (Math.random() - 0.5) * 40; // Â±20 per channel (reduced)
                            color[c] = Math.max(0, Math.min(255, color[c] + mutation));
                        }
                    }
                    
                    offspringColors[part].push(color);
                }
            }
            
            return offspringColors;
        }
        
        function inheritMemory(parent1, parent2) {
            // Combine memories from both parents
            const combinedMemory = [];
            
            // Take some memories from each parent
            const parent1Memories = parent1.memory.slice(-10); // Last 10 memories from parent1
            const parent2Memories = parent2.memory.slice(-10); // Last 10 memories from parent2
            
            // Interleave memories from both parents
            const maxLength = Math.max(parent1Memories.length, parent2Memories.length);
            for (let i = 0; i < maxLength; i++) {
                if (i < parent1Memories.length) {
                    combinedMemory.push({ ...parent1Memories[i] });
                }
                if (i < parent2Memories.length && combinedMemory.length < 15) {
                    combinedMemory.push({ ...parent2Memories[i] });
                }
            }
            
            // Add some mutation - randomly modify some inherited memories
            for (let memory of combinedMemory) {
                if (Math.random() < 0.1) { // 10% chance to mutate
                    // Slightly modify the movement direction
                    if (Math.random() < 0.5) {
                        memory.movement.dx += Math.random() < 0.5 ? -1 : 1;
                        memory.movement.dx = Math.max(-1, Math.min(1, memory.movement.dx));
                    }
                    if (Math.random() < 0.5) {
                        memory.movement.dy += Math.random() < 0.5 ? -1 : 1;
                        memory.movement.dy = Math.max(-1, Math.min(1, memory.movement.dy));
                    }
                }
            }
            
            return combinedMemory;
        }

        // Fractal tree growth functions
        function startTreeGrowth(x, y) {
            if (isValidPos(x, y)) {
                treeGrowthQueue.push({
                    x: x, y: y, direction: 0, length: Math.floor(Math.random() * 8) + 12,
                    thickness: 3, generation: 0, age: 0
                });
            }
        }
        
        function growFractalTree(treeNode, workingGrid) {
            if (treeNode.age >= treeNode.length || !isValidPos(treeNode.x, treeNode.y)) {
                return false;
            }
            
            if (workingGrid[treeNode.y][treeNode.x] === GLASS) {
                return false;
            }
            
            // Calculate direction with some randomness
            let dx = 0, dy = -1;
            if (treeNode.direction === -1) { dx = -1; dy = -1; }
            if (treeNode.direction === 1) { dx = 1; dy = -1; }
            
            // Add random sway to make trees more natural
            if (Math.random() < 0.3) {
                dx += (Math.random() - 0.5) * 0.8;
            }
            
            const nextX = Math.floor(treeNode.x + dx);
            const nextY = treeNode.y + dy;
            
            if (!isValidPos(nextX, nextY) || workingGrid[nextY][nextX] === GLASS) {
                return false;
            }
            
            // Place tree pixels with thickness (trunk width)
            for (let t = 0; t < treeNode.thickness; t++) {
                const growX = Math.floor(treeNode.x + (Math.random() - 0.5) * treeNode.thickness);
                const growY = treeNode.y;
                
                if (isValidPos(growX, growY) && workingGrid[growY][growX] === EMPTY) {
                    // Check if placing this pixel would cross glass
                    let blocked = false;
                    const steps = Math.abs(growX - treeNode.x);
                    for (let step = 0; step <= steps; step++) {
                        const checkX = treeNode.x + Math.sign(growX - treeNode.x) * step;
                        if (isValidPos(checkX, growY) && workingGrid[growY][checkX] === GLASS) {
                            blocked = true;
                            break;
                        }
                    }
                    
                    if (!blocked) {
                        workingGrid[growY][growX] = TREE;
                    }
                }
            }
            
            treeNode.x = nextX;
            treeNode.y = nextY;
            treeNode.age++;
            
            // Create branches with varying probability based on thickness (thicker = more branching)
            const branchProbability = 0.2 + (treeNode.thickness * 0.1);
            if (treeNode.generation < 3 && treeNode.age > 3 && treeNode.age % 4 === 0 && Math.random() < branchProbability) {
                // Left branch
                if (Math.random() < 0.5) {
                    treeGrowthQueue.push({
                        x: treeNode.x, y: treeNode.y, direction: -1,
                        length: Math.floor(treeNode.length * 0.7),
                        thickness: Math.max(1, treeNode.thickness - 1),
                        generation: treeNode.generation + 1, age: 0
                    });
                }
                // Right branch  
                if (Math.random() < 0.5) {
                    treeGrowthQueue.push({
                        x: treeNode.x, y: treeNode.y, direction: 1,
                        length: Math.floor(treeNode.length * 0.7),
                        thickness: Math.max(1, treeNode.thickness - 1),
                        generation: treeNode.generation + 1, age: 0
                    });
                }
            }
            
            return true;
        }
        
        
        
        // Worm functions
        function spawnThreePixelWorm(spawnCandidates, grid, lifeGrid) {
            // Shuffle candidates to pick random positions
            const shuffled = [...spawnCandidates];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            
            // Try to find 3 connected positions
            for (let i = 0; i < shuffled.length - 2; i++) {
                const head = shuffled[i];
                
                // Find positions adjacent to head for body
                const bodyOptions = shuffled.filter(pos => 
                    Math.abs(pos.x - head.x) <= 1 && Math.abs(pos.y - head.y) <= 1 && 
                    !(pos.x === head.x && pos.y === head.y)
                );
                
                if (bodyOptions.length > 0) {
                    const body = bodyOptions[0];
                    
                    // Find positions adjacent to body for tail
                    const tailOptions = shuffled.filter(pos => 
                        Math.abs(pos.x - body.x) <= 1 && Math.abs(pos.y - body.y) <= 1 && 
                        !(pos.x === head.x && pos.y === head.y) && 
                        !(pos.x === body.x && pos.y === body.y)
                    );
                    
                    if (tailOptions.length > 0) {
                        const tail = tailOptions[0];
                        
                        // Create the worm with unique default colors (deep clone)
                        const wormId = nextWormId++;
                        const defaultColors = {
                            tail: materialColors[INCHWORM].map(c => [...c]),          // deep-clone
                            head: materialColors[INCHWORM_HEAD].map(c => [...c]),
                            body: materialColors[INCHWORM_BODY].map(c => [...c])
                        };
                        // Founders start with base colors - inheritance happens in breeding
                        
                        const worm = {
                            id: wormId,
                            head: { x: head.x, y: head.y },
                            body: { x: body.x, y: body.y },
                            tail: { x: tail.x, y: tail.y },
                            life: materials[INCHWORM].life,
                            memory: [], // Array of movement memories: {position: {x, y}, movement: {dx, dy}, weight}
                            currentGoal: null, // Current movement intention: {dx, dy}
                            lastHeadPosition: null, // For stuck detection
                            colors: defaultColors, // Individual genetic colors
                            wasOnWater: false,
                            underHead: EMPTY
                        };
                        
                        wormList.push(worm);
                        attachAudioVoice(worm);
                        
                        // Place worm pixels
                        grid[head.y][head.x] = INCHWORM_HEAD;
                        grid[body.y][body.x] = INCHWORM_BODY;
                        grid[tail.y][tail.x] = INCHWORM;
                        
                        // Clear color cache for new worm colors to show
                        clearColorCache(head.x, head.y);
                        clearColorCache(body.x, body.y);
                        clearColorCache(tail.x, tail.y);
                        
                        lifeGrid[head.y][head.x] = worm.life;
                        lifeGrid[body.y][body.x] = worm.life;
                        lifeGrid[tail.y][tail.x] = worm.life;
                        
                        break;
                    }
                }
            }
        }
        
        function spawnOffspringWithInheritedMemory(spawnCandidates, grid, lifeGrid, parent1, parent2) {
            // First spawn the worm using the existing logic
            const shuffled = [...spawnCandidates];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            
            // Try to find 3 connected positions
            for (let i = 0; i < shuffled.length - 2; i++) {
                const head = shuffled[i];
                
                const bodyOptions = shuffled.filter(pos => 
                    Math.abs(pos.x - head.x) <= 1 && Math.abs(pos.y - head.y) <= 1 && 
                    !(pos.x === head.x && pos.y === head.y)
                );
                
                if (bodyOptions.length > 0) {
                    const body = bodyOptions[0];
                    
                    const tailOptions = shuffled.filter(pos => 
                        Math.abs(pos.x - body.x) <= 1 && Math.abs(pos.y - body.y) <= 1 && 
                        !(pos.x === head.x && pos.y === head.y) && 
                        !(pos.x === body.x && pos.y === body.y)
                    );
                    
                    if (tailOptions.length > 0) {
                        const tail = tailOptions[0];
                        
                        // Create the offspring worm with genetic color inheritance
                        const wormId = nextWormId++;
                        
                        // First inherit memory from parents
                        const inheritedMemory = inheritMemoryFromParents(parent1, parent2);
                        
                        // Then calculate genetics and colors based on memory inheritance
                        const genetics = calculateColorGenetics(parent1, parent2);
                        const offspringColors = generateOffspringColors(parent1, parent2, genetics, inheritedMemory);
                        
                        const offspring = {
                            id: wormId,
                            head: { x: head.x, y: head.y },
                            body: { x: body.x, y: body.y },
                            tail: { x: tail.x, y: tail.y },
                            life: materials[INCHWORM].life,
                            memory: inheritedMemory, // Inherited memory from parents
                            currentGoal: null,
                            lastHeadPosition: null,
                            colors: offspringColors, // Individual genetic colors based on memory
                            wasOnWater: false,
                            underHead: EMPTY
                        };
                        
                        wormList.push(offspring);
                        attachAudioVoice(offspring);
                        
                        // Place worm pixels
                        grid[head.y][head.x] = INCHWORM_HEAD;
                        grid[body.y][body.x] = INCHWORM_BODY;
                        grid[tail.y][tail.x] = INCHWORM;
                        
                        // Clear color cache for genetic colors to show
                        clearColorCache(head.x, head.y);
                        clearColorCache(body.x, body.y);
                        clearColorCache(tail.x, tail.y);
                        
                        lifeGrid[head.y][head.x] = offspring.life;
                        lifeGrid[body.y][body.x] = offspring.life;
                        lifeGrid[tail.y][tail.x] = offspring.life;
                        
                        break;
                    }
                }
            }
        }
        
        function inheritMemoryFromParents(parent1, parent2) {
            // Get recent memories from each parent (both positive and negative for color inheritance)
            const parent1Recent = parent1.memory
                .slice(-10) // Last 10 memories
                .sort((a, b) => Math.abs(b.weight) - Math.abs(a.weight)) // Sort by memory strength
                .slice(0, 8); // Top 8 strongest memories
                
            const parent2Recent = parent2.memory
                .slice(-10) // Last 10 memories  
                .sort((a, b) => Math.abs(b.weight) - Math.abs(a.weight)) // Sort by memory strength
                .slice(0, 8); // Top 8 strongest memories
            
            // Interleave memories from both parents
            const inheritedMemory = [];
            const maxLength = Math.max(parent1Recent.length, parent2Recent.length);
            
            for (let i = 0; i < maxLength && inheritedMemory.length < 16; i++) {
                if (i < parent1Recent.length) {
                    inheritedMemory.push(mutateMemory(parent1Recent[i]));
                }
                if (i < parent2Recent.length && inheritedMemory.length < 16) {
                    inheritedMemory.push(mutateMemory(parent2Recent[i]));
                }
            }
            
            return inheritedMemory;
        }
        
        function mutateMemory(memory) {
            // Create a slightly mutated copy of the memory
            const mutated = {
                relativeElevation: memory.relativeElevation,
                localTreeDensity: memory.localTreeDensity,
                localPixelClass: memory.localPixelClass,
                movement: { dx: memory.movement.dx, dy: memory.movement.dy },
                weight: memory.weight,
                key: memory.key,
                kind: memory.kind
            };
            
            // 20% chance to mutate weight slightly
            if (Math.random() < 0.2) {
                const mutation = Math.random() < 0.5 ? -1 : 1;
                mutated.weight = Math.max(-5, Math.min(5, mutated.weight + mutation));
                // Update key if weight changed significantly
                mutated.key = `${mutated.relativeElevation},${mutated.localTreeDensity},${mutated.localPixelClass},${mutated.movement.dx},${mutated.movement.dy}`;
            }
            
            return mutated;
        }
        
        function isWormSubmerged(worm, waterThreshold = 6) {
            // Count WATER vs AIR (EMPTY) neighbours around all three segments.
            let waterContacts = 0;
            let airContacts   = 0;

            const parts = [worm.head, worm.body, worm.tail];
            for (const p of parts) {
                for (let dy=-1; dy<=1; dy++) {
                    for (let dx=-1; dx<=1; dx++) {
                        if (dx===0 && dy===0) continue;
                        const nx = p.x + dx, ny = p.y + dy;
                        if (!isValidPos(nx,ny)) continue;
                        const c = grid[ny][nx];
                        if (c === WATER) waterContacts++;
                        else if (c === EMPTY || c === STEAM) airContacts++;
                    }
                }
            }
            // submerged if lots of water *and* almost no air
            return waterContacts >= waterThreshold && airContacts < 3;
        }
        
        function checkWormBreeding() {
            // Check every worm against every other worm for breeding opportunities
            for (let i = 0; i < wormList.length; i++) {
                for (let j = i + 1; j < wormList.length; j++) {
                    const worm1 = wormList[i];
                    const worm2 = wormList[j];
                    
                    // Check if worms are close enough to breed (any part within 2 pixels)
                    if (areWormsClose(worm1, worm2)) {
                        // Skip breeding if either worm is submerged.
                        if (isWormSubmerged(worm1) || isWormSubmerged(worm2)) {
                            continue; // go check next pair
                        }
                        
                        // Breeding conditions: both worms must be mature (lived at least 25 frames)
                        const worm1Age = materials[INCHWORM].life - worm1.life;
                        const worm2Age = materials[INCHWORM].life - worm2.life;
                        
                        // Simple breeding chance - just based on proximity and age
                        let breedingChance = 0.08; // Base 8% chance
                        
                        if (worm1Age >= 25 && worm2Age >= 25 && Math.random() < breedingChance) {
                            // Attempt to breed
                            attemptWormBreeding(worm1, worm2);
                        }
                    }
                }
            }
        }
        
        function areWormsClose(worm1, worm2) {
            // Check if any part of worm1 is within 2 pixels of any part of worm2
            const worm1Parts = [worm1.head, worm1.body, worm1.tail];
            const worm2Parts = [worm2.head, worm2.body, worm2.tail];
            
            for (const part1 of worm1Parts) {
                for (const part2 of worm2Parts) {
                    const distance = Math.abs(part1.x - part2.x) + Math.abs(part1.y - part2.y);
                    if (distance <= 2) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        function isCellWaterlogged(x,y,limit=5){
            let w=0;
            for (let dy=-1; dy<=1; dy++){
                for (let dx=-1; dx<=1; dx++){
                    if (dx===0 && dy===0) continue;
                    const nx=x+dx, ny=y+dy;
                    if (!isValidPos(nx,ny)) continue;
                    if (grid[ny][nx] === WATER) w++;
                }
            }
            return w >= limit;
        }
        
        function attemptWormBreeding(worm1, worm2) {
            // Find breeding area - look for empty spaces near both worms
            const breedingCandidates = [];
            
            // Check area around both worms for empty spaces with surface contact
            const checkAreas = [
                [worm1.head, worm1.body, worm1.tail],
                [worm2.head, worm2.body, worm2.tail]
            ];
            
            for (const wormParts of checkAreas) {
                for (const part of wormParts) {
                    // Check 3x3 area around each worm part
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const x = part.x + dx;
                            const y = part.y + dy;
                            
                            if (isValidPos(x, y) && grid[y][x] === EMPTY) {
                                if (hasValidSurface(x, y) && !isCellWaterlogged(x, y)) {
                                    breedingCandidates.push({ x, y });
                                }
                            }
                        }
                    }
                }
            }
            
            // Remove duplicates
            const uniqueCandidates = breedingCandidates.filter((candidate, index, arr) => 
                arr.findIndex(c => c.x === candidate.x && c.y === candidate.y) === index
            );
            
            // Spawn new worm if enough space
            if (uniqueCandidates.length >= 3) {
                spawnOffspringWithInheritedMemory(uniqueCandidates, grid, inchwormLifeGrid, worm1, worm2);
                
                // Play mating sounds for both parents
                playWormEvent(worm1, 'mating');
                playWormEvent(worm2, 'mating');
                
                // Record breeding success in memory (reward recent moves that led to breeding)
                recordBreedingSuccess(worm1);
                recordBreedingSuccess(worm2);
                
                // Reduce life of parent worms (breeding cost)
                worm1.life -= 15;
                worm2.life -= 15;
            } else {
                // Record breeding failure (not enough space)
                recordBreedingFailure(worm1);
                recordBreedingFailure(worm2);
            }
        }
        
        function updateWorms() {
            // Update worms every few frames for performance
            if (treeUpdateCounter % 6 !== 0) return;
            
            // Check for breeding opportunities first
            checkWormBreeding();
            
            for (let i = wormList.length - 1; i >= 0; i--) {
                const worm = wormList[i];
                
                // Age the worm
                worm.life--;
                if (worm.life <= 0) {
                    // Remove dead worm
                    removeWorm(worm);
                    wormList.splice(i, 1);
                    continue;
                }
                
                // Check if worm died (in water/lava or eaten)
                if (!isWormAlive(worm)) {
                    removeWorm(worm);
                    wormList.splice(i, 1);
                    continue;
                }
                
                // Audio is now event-driven, no continuous updates needed
                
                // Move the worm
                moveWorm(worm);
            }
        }
        
        function isWormAlive(worm) {
            // Check if all parts of the worm still exist and aren't in deadly materials
            const headCell = grid[worm.head.y] && grid[worm.head.y][worm.head.x];
            const bodyCell = grid[worm.body.y] && grid[worm.body.y][worm.body.x];
            const tailCell = grid[worm.tail.y] && grid[worm.tail.y][worm.tail.x];
            
            return headCell === INCHWORM_HEAD && 
                   bodyCell === INCHWORM_BODY && 
                   tailCell === INCHWORM;
        }
        
        function removeWorm(worm) {
            // Convert dead worm pixels to acid
            if (isValidPos(worm.head.x, worm.head.y) && grid[worm.head.y][worm.head.x] === INCHWORM_HEAD) {
                grid[worm.head.y][worm.head.x] = ACID;
                acidLifeGrid[worm.head.y][worm.head.x] = materials[ACID].life;
                inchwormLifeGrid[worm.head.y][worm.head.x] = 0;
            }
            if (isValidPos(worm.body.x, worm.body.y) && grid[worm.body.y][worm.body.x] === INCHWORM_BODY) {
                grid[worm.body.y][worm.body.x] = ACID;
                acidLifeGrid[worm.body.y][worm.body.x] = materials[ACID].life;
                inchwormLifeGrid[worm.body.y][worm.body.x] = 0;
            }
            if (isValidPos(worm.tail.x, worm.tail.y) && grid[worm.tail.y][worm.tail.x] === INCHWORM) {
                grid[worm.tail.y][worm.tail.x] = ACID;
                acidLifeGrid[worm.tail.y][worm.tail.x] = materials[ACID].life;
                inchwormLifeGrid[worm.tail.y][worm.tail.x] = 0;
            }
            
            // Play dying sound and cleanup persistent voice
            if (worm.voice) {
                playWormEvent(worm, 'dying');
                
                // Remove from allocated voices immediately to free up slot
                const voiceIndex = allocatedVoices.indexOf(worm);
                if (voiceIndex > -1) {
                    allocatedVoices.splice(voiceIndex, 1);
                    
                    // Try to reallocate the freed voice to a silent worm
                    reallocateVoiceToSilentWorm();
                }
                
                // Clean up persistent oscillators after envelope decay
                if (worm.voice.hasVoice) {
                    const now = audioCtx.currentTime;
                    const dyingDuration = 0.4; // Match dying sound duration
                    const fadeBuffer = 0.05; // Small buffer for fade
                    const SILENCE = 0.002; // -54 dB threshold
                    const offTime = now + dyingDuration + fadeBuffer + 0.1; // After envelope silent
                    
                    // Fade out voice gain smoothly before stopping
                    worm.voice.voiceGain.gain.cancelScheduledValues(now + dyingDuration);
                    worm.voice.voiceGain.gain.setValueAtTime(worm.voice.voiceGain.gain.value, now + dyingDuration);
                    worm.voice.voiceGain.gain.exponentialRampToValueAtTime(0.001, now + dyingDuration + fadeBuffer);
                    
                    // Schedule oscillator stops only after envelope is silent
                    ['carrier1', 'carrier2', 'modulator'].forEach(name => {
                        const osc = worm.voice[name];
                        if (osc) osc.stop(offTime);
                    });
                    
                    // Clear hasVoice flag and cleanup nodes to prevent memory leaks
                    setTimeout(() => {
                        if (worm.voice) {
                            // Disconnect and nullify oscillators
                            ['carrier1', 'carrier2', 'modulator'].forEach(name => {
                                const osc = worm.voice[name];
                                if (osc) {
                                    osc.disconnect();
                                    worm.voice[name] = null;
                                }
                            });
                            worm.voice.hasVoice = false;
                        }
                    }, (dyingDuration + fadeBuffer + 0.1 + 0.01) * 1000);
                }
            }
        }
        
        function moveWorm(worm) {
            // Set movement goal based on memory and environment
            if (!worm.currentGoal) {
                worm.currentGoal = generateMovementGoal(worm);
            }
            
            // Periodically generate new goals to prevent getting stuck in loops
            if (worm.memory.length > 0 && Math.random() < 0.05) {
                const newGoal = generateMovementGoal(worm);
                if (newGoal) {
                    worm.currentGoal = newGoal;
                }
            }
            
            // Check if worm needs to fall (no solid support)
            // A worm is unsupported if it has no solid ground contact (not just any surface)
            let hasSolidGroundSupport = false;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const checkX = worm.head.x + dx;
                    const checkY = worm.head.y + dy;
                    
                    if (isValidPos(checkX, checkY)) {
                        const cell = grid[checkY][checkX];
                        
                        // Only count solid surfaces for support (not other worms)
                        if (cell === SAND || cell === DIRT || cell === GLASS || 
                            cell === TREE || cell === DEAD_TREE || cell === WATER) {
                            // Skip surfaces above the worm (they don't provide support)
                            if (checkY >= worm.head.y) {
                                hasSolidGroundSupport = true;
                                break;
                            }
                        }
                    }
                }
                if (hasSolidGroundSupport) break;
            }
            
            const isUnsupported = !hasSolidGroundSupport;
            
            const allMoves = [];
            
            // If unsupported, prioritize falling moves
            if (isUnsupported) {
                // Add falling options
                const fallCandidates = [
                    { x: worm.head.x, y: worm.head.y + 1 },     // Straight down
                    { x: worm.head.x - 1, y: worm.head.y + 1 }, // Down-left
                    { x: worm.head.x + 1, y: worm.head.y + 1 }  // Down-right
                ];
                
                for (const candidate of fallCandidates) {
                    if (isValidPos(candidate.x, candidate.y)) {
                        const targetCell = grid[candidate.y][candidate.x];
                        const isOwnBodyPart = (candidate.x === worm.body.x && candidate.y === worm.body.y) || 
                                             (candidate.x === worm.tail.x && candidate.y === worm.tail.y);
                        
                        if (!isOwnBodyPart && (targetCell === EMPTY || targetCell === TREE || targetCell === WATER)) {
                            allMoves.push({ 
                                x: candidate.x, 
                                y: candidate.y, 
                                dx: candidate.x - worm.head.x,
                                dy: candidate.y - worm.head.y,
                                eatsTree: targetCell === TREE,
                                floatsOnWater: targetCell === WATER,
                                isFalling: true
                            });
                        }
                    }
                }
            }
            
            // Add regular surface-following moves
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const newX = worm.head.x + dx;
                    const newY = worm.head.y + dy;
                    
                    if (isValidPos(newX, newY)) {
                        const targetCell = grid[newY][newX];
                        
                        // Skip own body parts
                        const isOwnBodyPart = (newX === worm.body.x && newY === worm.body.y) || 
                                             (newX === worm.tail.x && newY === worm.tail.y);
                        
                        if (!isOwnBodyPart && (targetCell === EMPTY || targetCell === TREE || targetCell === WATER || 
                                                        (targetCell === DIRT && newY < worm.head.y))) { // Allow dirt swapping for upward movement
                            // For non-falling moves, require surface contact (worms can't fly)
                            if (hasValidSurface(newX, newY, { includeWorms: false })) {
                                // Also check that the worm itself will have support after moving
                                // A worm needs at least one solid contact point to crawl
                                let hasSolidSupport = false;
                                
                                // Check for solid ground/surfaces around the new position
                                for (let sdy = -1; sdy <= 1; sdy++) {
                                    for (let sdx = -1; sdx <= 1; sdx++) {
                                        if (sdx === 0 && sdy === 0) continue;
                                        
                                        const supportX = newX + sdx;
                                        const supportY = newY + sdy;
                                        
                                        if (isValidPos(supportX, supportY)) {
                                            const supportCell = grid[supportY][supportX];
                                            
                                            // Count solid surfaces only (no worms as structural support)
                                            if (supportCell === SAND || supportCell === DIRT || supportCell === GLASS || 
                                                supportCell === TREE || supportCell === DEAD_TREE || supportCell === WATER) {
                                                hasSolidSupport = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (hasSolidSupport) break;
                                }
                                
                                // Only allow crawling moves with proper support
                                if (hasSolidSupport) {
                                    allMoves.push({ 
                                        x: newX, 
                                        y: newY, 
                                        dx: dx,
                                        dy: dy,
                                        eatsTree: targetCell === TREE,
                                        floatsOnWater: targetCell === WATER,
                                        displacesDirt: targetCell === DIRT,
                                        isFalling: false
                                    });
                                }
                            }
                        }
                    }
                }
            }
            
            // Check if worm is in same position as last turn (stuck)
            const currentHeadPos = `${worm.head.x},${worm.head.y}`;
            const wasStuck = worm.lastHeadPosition === currentHeadPos;
            
            // Worms ALWAYS move when any options exist - never stop!
            if (allMoves.length > 0) {
                selectedMove = selectBestMove(worm, allMoves);
                
                // Force selection if no move was chosen (shouldn't happen with good logic)
                if (!selectedMove) {
                    selectedMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                }
            } else {
                // No moves available - use emergency maneuvers
                handleStuckWorm(worm, wasStuck);
                return;
            }
            
            // Execute the selected move
            if (selectedMove) {
                executeWormMove(worm, selectedMove);
            }
        }
        
        
        
        
        function findNearestFood(worm) {
            // Look for trees (food) in a 8x8 area around the worm
            const searchRadius = 8;
            let nearestFood = null;
            let minDistance = Infinity;
            
            for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const checkX = worm.head.x + dx;
                    const checkY = worm.head.y + dy;
                    
                    if (isValidPos(checkX, checkY) && grid[checkY][checkX] === TREE) {
                        const distance = Math.abs(dx) + Math.abs(dy);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestFood = { dx: Math.sign(dx), dy: Math.sign(dy) };
                        }
                    }
                }
            }
            
            return nearestFood;
        }
        
        function findTreeCluster(worm) {
            // Find the densest tree cluster within range
            const searchRadius = 7;
            let bestCluster = null;
            let maxDensity = 0;
            
            for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const centerX = worm.head.x + dx;
                    const centerY = worm.head.y + dy;
                    
                    if (isValidPos(centerX, centerY)) {
                        // Count trees in 3x3 area around this center point
                        let treeCount = 0;
                        for (let cy = -1; cy <= 1; cy++) {
                            for (let cx = -1; cx <= 1; cx++) {
                                const checkX = centerX + cx;
                                const checkY = centerY + cy;
                                if (isValidPos(checkX, checkY) && grid[checkY][checkX] === TREE) {
                                    treeCount++;
                                }
                            }
                        }
                        
                        // Calculate density score (trees per distance)
                        const distance = Math.abs(dx) + Math.abs(dy);
                        const density = treeCount / Math.max(1, distance);
                        
                        if (density > maxDensity && treeCount >= 2) { // Need at least 2 trees to be a cluster
                            maxDensity = density;
                            bestCluster = { 
                                dx: Math.sign(dx), 
                                dy: Math.sign(dy),
                                density: density,
                                treeCount: treeCount
                            };
                        }
                    }
                }
            }
            
            return bestCluster;
        }
        
        function generateMovementGoal(worm) {
            // Priority: Tree clusters â†’ Nearest food â†’ Exploration
            
            // First priority: Move toward dense tree clusters
            const treeCluster = findTreeCluster(worm);
            if (treeCluster) {
                return { 
                    dx: treeCluster.dx, 
                    dy: treeCluster.dy,
                    isClusterSeeking: true,
                    clusterDensity: treeCluster.density
                };
            }
            
            // Second priority: Move toward nearest single tree
            const foodDirection = findNearestFood(worm);
            if (foodDirection) {
                return { dx: foodDirection.dx, dy: foodDirection.dy };
            }
            
            // If no food nearby, create exploration goal based on memory
            if (worm.memory.length > 3) {
                const recentMoves = worm.memory.slice(-3);
                const avgDx = recentMoves.reduce((sum, m) => sum + m.movement.dx, 0) / recentMoves.length;
                const avgDy = recentMoves.reduce((sum, m) => sum + m.movement.dy, 0) / recentMoves.length;
                
                // Continue in similar direction
                return {
                    dx: Math.sign(avgDx) || (Math.random() < 0.5 ? -1 : 1),
                    dy: Math.sign(avgDy) || (Math.random() < 0.5 ? -1 : 1)
                };
            }
            
            // Random exploration direction
            return {
                dx: Math.random() < 0.5 ? -1 : 1,
                dy: Math.random() < 0.5 ? -1 : 1
            };
        }
        
        
        function selectBestMove(worm, availableMoves) {
            // Rebalanced priority system: Tree clusters â†’ Food â†’ Surface contact â†’ Falling
            
            if (availableMoves.length === 0) {
                return null;
            }
            
            // First priority: Food moves (eating is always top priority)
            const foodMoves = availableMoves.filter(move => move.eatsTree);
            if (foodMoves.length > 0) {
                return selectMemoryWeightedMove(worm, foodMoves);
            }
            
            // Second priority: Moves toward other worms (social attraction)
            const nearbyWorms = findNearbyWorms(worm.head.x, worm.head.y, 8);
            if (nearbyWorms.length > 0) {
                // Filter moves that go toward nearby worms
                const wormAttractionMoves = availableMoves.filter(move => {
                    const movePos = { x: move.x, y: move.y };
                    return nearbyWorms.some(nearby => {
                        const currentDist = Math.abs(worm.head.x - nearby.part.x) + Math.abs(worm.head.y - nearby.part.y);
                        const newDist = Math.abs(movePos.x - nearby.part.x) + Math.abs(movePos.y - nearby.part.y);
                        return newDist < currentDist; // Move gets closer to worm
                    });
                });
                
                if (wormAttractionMoves.length > 0) {
                    return selectMemoryWeightedMove(worm, wormAttractionMoves);
                }
            }
            
            // Third priority: Moves toward tree clusters (but not falling)
            const nonFallingMoves = availableMoves.filter(move => !move.isFalling);
            if (nonFallingMoves.length > 0 && worm.currentGoal && worm.currentGoal.isClusterSeeking) {
                // Filter moves that go toward the cluster
                const clusterMoves = nonFallingMoves.filter(move => 
                    Math.sign(move.dx) === Math.sign(worm.currentGoal.dx) || 
                    Math.sign(move.dy) === Math.sign(worm.currentGoal.dy)
                );
                
                if (clusterMoves.length > 0) {
                    return selectMemoryWeightedMove(worm, clusterMoves);
                }
            }
            
            // Fourth priority: Any surface-contact moves (avoid falling if possible)
            if (nonFallingMoves.length > 0) {
                return selectMemoryWeightedMove(worm, nonFallingMoves);
            }
            
            // Last resort: Falling moves (only when no surface contact possible)
            const fallingMoves = availableMoves.filter(move => move.isFalling);
            if (fallingMoves.length > 0) {
                return selectMemoryWeightedMove(worm, fallingMoves);
            }
            
            // Fallback
            return selectMemoryWeightedMove(worm, availableMoves);
        }
        
        function selectMemoryWeightedMove(worm, moves) {
            // Use memory to weight move selection, with goal influence and surface following
            if (moves.length === 0) {
                return null;
            }
            
            if (moves.length === 1) {
                return moves[0];
            }
            
            // Score moves based on memory, goals, and surface following
            const scoredMoves = moves.map(move => {
                let score = 1.0; // Base score
                
                // Instant chemistry bias: prefer favorable pixel environments
                switch (sampleLocalPixelClass(move.x, move.y)) {
                    case  2: score += 0.6; break; // rich in trees / dirt
                    case  1: score += 0.3; break; // water present
                    case -2: score -= 0.9; break; // acid / fire / lava nearby
                }
                
                // Surface following bonus: prefer moves that maintain contact with surfaces
                if (!move.isFalling) {
                    const surfaceQuality = calculateSurfaceContactQuality(move.x, move.y, worm);
                    score += surfaceQuality * 0.3; // Surface contact bonus
                }
                
                // Social attraction bonus: prefer moves toward nearby worms
                const nearbyWorms = findNearbyWorms(move.x, move.y, 6);
                if (nearbyWorms.length > 0) {
                    // Stronger attraction to closer worms
                    const attractionBonus = nearbyWorms.reduce((total, nearby) => {
                        const attractionStrength = Math.max(0, 1 - (nearby.distance / 6)); // Stronger when closer
                        return total + attractionStrength * 0.2; // Social attraction bonus
                    }, 0);
                    score += attractionBonus;
                }
                
                // Memory scoring: environmental context + movement matches
                if (worm.memory.length > 0) {
                    const currentElevation = calculateRelativeElevation(worm.head.x, worm.head.y);
                    const currentTreeDensity = calculateLocalTreeDensity(worm.head.x, worm.head.y);
                    const localPixelClass = sampleLocalPixelClass(worm.head.x, worm.head.y);
                    const moveKey = `${currentElevation},${currentTreeDensity},${localPixelClass},${move.dx},${move.dy}`;
                    
                    // Exact environmental context + movement match
                    const exactMemory = worm.memory.find(mem => mem.key === moveKey);
                    if (exactMemory) {
                        score += exactMemory.weight;
                    }
                    
                    // Similar environmental contexts (fuzzy matching)
                    const similarContexts = worm.memory.filter(mem => 
                        Math.abs(mem.relativeElevation - currentElevation) <= 1 &&
                        Math.abs(mem.localTreeDensity - currentTreeDensity) <= 2 &&
                        Math.abs(mem.localPixelClass - localPixelClass) <= 1 &&
                        mem.movement.dx === move.dx && mem.movement.dy === move.dy
                    );
                    
                    if (similarContexts.length > 0) {
                        const avgWeight = similarContexts.reduce((sum, mem) => sum + mem.weight, 0) / similarContexts.length;
                        score += avgWeight * 0.3; // Contextual similarity bonus
                    }
                }
                
                // Goal alignment bonus (enhanced for cluster seeking)
                if (worm.currentGoal) {
                    if (move.dx === worm.currentGoal.dx && move.dy === worm.currentGoal.dy) {
                        if (worm.currentGoal.isClusterSeeking) {
                            score += 1.0; // Strong bonus for exact cluster direction
                        } else {
                            score += 0.5; // Normal exact goal match
                        }
                    } else if (Math.sign(move.dx) === Math.sign(worm.currentGoal.dx) || 
                              Math.sign(move.dy) === Math.sign(worm.currentGoal.dy)) {
                        if (worm.currentGoal.isClusterSeeking) {
                            score += 0.5; // Bonus for similar cluster direction
                        } else {
                            score += 0.2; // Normal similar direction
                        }
                    }
                }
                
                // Extra bonus for moves toward tree clusters
                if (worm.currentGoal && worm.currentGoal.isClusterSeeking && !move.isFalling) {
                    score += worm.currentGoal.clusterDensity || 0.3; // Density-based bonus
                }
                
                return { move, score };
            });
            
            // Ensure all scores are positive
            const minScore = Math.min(...scoredMoves.map(item => item.score));
            if (minScore <= 0) {
                scoredMoves.forEach(item => item.score += Math.abs(minScore) + 0.1);
            }
            
            // Weighted random selection
            const totalScore = scoredMoves.reduce((sum, item) => sum + item.score, 0);
            let random = Math.random() * totalScore;
            
            for (const item of scoredMoves) {
                random -= item.score;
                if (random <= 0) {
                    return item.move;
                }
            }
            
            // Fallback
            return moves[Math.floor(Math.random() * moves.length)];
        }
        
        function calculateSurfaceContactQuality(x, y, worm) {
            // Calculate how good the surface contact is at this position
            let quality = 0;
            let contactCount = 0;
            
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const sx = x + dx;
                    const sy = y + dy;
                    
                    if (isValidPos(sx, sy)) {
                        const cell = grid[sy][sx];
                        
                        // Check for solid surfaces
                        if (cell === SAND || cell === DIRT || cell === GLASS || 
                            cell === TREE || cell === DEAD_TREE || cell === WATER) {
                            contactCount++;
                            
                            // Prefer contact below and to sides (more stable)
                            if (sy >= y) quality += 1.0; // Below or same level
                            else quality += 0.5; // Above
                        }
                        
                    }
                }
            }
            
            // Normalize quality by contact count (prefer multiple contact points)
            return contactCount > 0 ? quality / Math.max(1, contactCount) : 0;
        }
        
        function findNearbyWorms(x, y, radius = 5) {
            // Find other worms within the specified radius
            const nearbyWorms = [];
            
            for (const otherWorm of wormList) {
                // Check distance to all parts of the other worm
                const parts = [otherWorm.head, otherWorm.body, otherWorm.tail];
                for (const part of parts) {
                    const distance = Math.abs(part.x - x) + Math.abs(part.y - y); // Manhattan distance
                    if (distance <= radius) {
                        nearbyWorms.push({
                            worm: otherWorm,
                            distance: distance,
                            part: part
                        });
                        break; // Only count each worm once
                    }
                }
            }
            
            return nearbyWorms;
        }
                                
        function executeWormMove(worm, selectedMove) {
            /* â”€â”€ 0.  Play movement-triggered FM audio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
            playWormMovement(worm, selectedMove);
            
            /* â”€â”€ 1.  Memorise the cell we are about to step into â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
            const nextSubstrate = grid[selectedMove.y][selectedMove.x];

            /* NEW â†“ â€“ remember if weâ€™re about to walk into water */
            const willDisplaceWater = nextSubstrate === WATER;

            /* â”€â”€ 2.  Log this movement for learning purposes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
            const successType = selectedMove.eatsTree ? 'tree' : null;
            recordMovementMemory(worm, selectedMove, successType);

            /* â”€â”€ 3.  Snapshot current segment positions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
            const oldTail = { ...worm.tail };
            const oldBody = { ...worm.body };
            const oldHead = { ...worm.head };

            /* â”€â”€ 4.  Restore what the head had been covering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
            grid[oldHead.y][oldHead.x] = worm.underHead ?? EMPTY;

            /* â”€â”€ 5.  Clear the other two segments from the grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
            grid[oldBody.y][oldBody.x] = EMPTY;
            grid[oldTail.y][oldTail.x] = EMPTY;
            inchwormLifeGrid[oldHead.y][oldHead.x] =
            inchwormLifeGrid[oldBody.y][oldBody.x] =
            inchwormLifeGrid[oldTail.y][oldTail.x] = 0;
            clearColorCache(oldHead.x, oldHead.y);
            clearColorCache(oldBody.x, oldBody.y);
            clearColorCache(oldTail.x, oldTail.y);

            /* â”€â”€ 6.  Shift the segments â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
            if (selectedMove.isFalling) {
                worm.head = selectedMove;
                worm.body = oldHead;
                worm.tail = oldBody;
            } else {
                worm.tail = oldBody;
                worm.body = oldHead;
                worm.head = selectedMove;
            }

            /* â”€â”€ 7.  Special case: pushing dirt upward ------------------------- */
            if (grid[worm.head.y][worm.head.x] === DIRT) {
                grid[oldHead.y][oldHead.x] = DIRT;
                grid[worm.head.y][worm.head.x] = EMPTY;
            }

            /* â”€â”€ 8.  Stamp the wormâ€™s new pixels onto the grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
            grid[worm.tail.y][worm.tail.x]  = INCHWORM;
            grid[worm.body.y][worm.body.x]  = INCHWORM_BODY;
            grid[worm.head.y][worm.head.x]  = INCHWORM_HEAD;
            clearColorCache(worm.tail.x, worm.tail.y);
            clearColorCache(worm.body.x, worm.body.y);
            clearColorCache(worm.head.x, worm.head.y);
            inchwormLifeGrid[worm.tail.y][worm.tail.x] =
            inchwormLifeGrid[worm.body.y][worm.body.x] =
            inchwormLifeGrid[worm.head.y][worm.head.x] = worm.life;

            /* NEW â†“ â€“ put the displaced water where the tail just was */
            if (willDisplaceWater) {
                let wx = oldTail.x, wy = oldTail.y;

                if (grid[wy][wx] !== EMPTY) {
                    // tail square got reused â€“ look for a neighbouring empty one
                    const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
                    for (const [dx,dy] of dirs) {
                        const tx = wx + dx, ty = wy + dy;
                        if (isValidPos(tx,ty) && grid[ty][tx] === EMPTY) {
                            wx = tx; wy = ty; break;
                        }
                    }
                }
                if (grid[wy][wx] === EMPTY) {
                    grid[wy][wx] = WATER;
                    clearColorCache(wx, wy);
                }
            }

            /* â”€â”€ 9.  Handle eating a tree pixel (energy gain) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
            if (selectedMove.eatsTree) {
                worm.life = Math.min(worm.life + 1, materials[INCHWORM].life * 1.2);
                playWormEvent(worm, 'eating');
            }

            /* â”€â”€ 10.  Houseâ€‘keeping for next turn â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
            worm.underHead = nextSubstrate;
            
            // Trigger material contact sound
            if (worm.voice && MATERIAL_TONE[nextSubstrate] && nextSubstrate !== worm.voice.lastMaterial) {
                playWormEvent(worm, 'material');
                worm.voice.lastMaterial = nextSubstrate;
            }
            
            worm.lastHeadPosition = `${worm.head.x},${worm.head.y}`;
        }


        
        function handleStuckWorm(worm, wasStuck) {
            // Simplified emergency movement for stuck worms
            if (!wasStuck) {
                // First time stuck - reverse direction by swapping head and tail
                const oldHead = { ...worm.head };
                const oldTail = { ...worm.tail };
                
                worm.head = oldTail;
                worm.tail = oldHead;
                
                // Update grid positions
                grid[worm.head.y][worm.head.x] = INCHWORM_HEAD;
                grid[worm.tail.y][worm.tail.x] = INCHWORM;
            } else {
                // Still stuck - cycle body positions as last resort
                const oldTail = { ...worm.tail };
                const oldBody = { ...worm.body };
                const oldHead = { ...worm.head };
                
                worm.head = oldBody;
                worm.body = oldTail;
                worm.tail = oldHead;
                
                // Update grid positions
                grid[worm.head.y][worm.head.x] = INCHWORM_HEAD;
                grid[worm.body.y][worm.body.x] = INCHWORM_BODY;
                grid[worm.tail.y][worm.tail.x] = INCHWORM;
            }
            
            worm.lastHeadPosition = `${worm.head.x},${worm.head.y}`;
        }
        
        
        function recordBreedingSuccess(worm) {
            // Reward recent movements that led to successful breeding
            const recentMoves = worm.memory.slice(-3); // Last 3 moves led to breeding
            for (const memory of recentMoves) {
                memory.weight += 2; // Breeding success bonus
                memory.weight = Math.min(5, memory.weight); // Cap at 5
            }
        }
        
        function recordBreedingFailure(worm) {
            // Penalize recent movements that led to failed breeding attempt
            const recentMoves = worm.memory.slice(-2); // Last 2 moves led to failed breeding
            for (const memory of recentMoves) {
                memory.weight -= 1; // Breeding failure penalty
                memory.weight = Math.max(-5, memory.weight); // Cap at -5
            }
        }
        
        function calculateRelativeElevation(x, y) {
            // Calculate relative elevation: how many solid pixels are below vs above
            let below = 0, above = 0;
            
            for (let dy = 1; dy <= 3; dy++) { // Check 3 pixels below
                if (isValidPos(x, y + dy)) {
                    const cell = grid[y + dy][x];
                    if (cell === SAND || cell === DIRT || cell === GLASS || 
                        cell === TREE || cell === DEAD_TREE) {
                        below++;
                    }
                }
            }
            
            for (let dy = 1; dy <= 3; dy++) { // Check 3 pixels above
                if (isValidPos(x, y - dy)) {
                    const cell = grid[y - dy][x];
                    if (cell === SAND || cell === DIRT || cell === GLASS || 
                        cell === TREE || cell === DEAD_TREE) {
                        above++;
                    }
                }
            }
            
            // Return relative elevation: -3 (deep valley) to +3 (high peak)
            return below - above;
        }
        
        function calculateLocalTreeDensity(x, y) {
            // Count trees in 5x5 area around position
            let treeCount = 0;
            const radius = 2;
            
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (isValidPos(x + dx, y + dy) && grid[y + dy][x + dx] === TREE) {
                        treeCount++;
                    }
                }
            }
            
            // Return density 0-25 (max trees in 5x5)
            return treeCount;
        }
        
        function sampleLocalPixelClass(x, y) {
            // Scan the Moore neighbourhood around (x,y) for chemical preference
            let score = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = x + dx, ny = y + dy;
                    if (!isValidPos(nx, ny)) continue;
                    const c = grid[ny][nx];

                    if (c === TREE || c === DIRT || c === DEAD_TREE) score += 2;
                    else if (c === WATER)                                score += 1;
                    else if (c === ACID || c === FIRE || c === LAVA)     score -= 4;
                    // EMPTY / STEAM etc count as 0
                }
            }
            // Clamp to -4â€¦4 so the key stays compact
            return Math.max(-4, Math.min(4, score));
        }
        
        function recordMovementMemory(worm, move, success = null) {
            // Record this movement in memory with environmental context instead of position
            let weight = 0;
            
            // Determine success/failure weight
            if (success === 'tree') {
                weight = 1; // Found food
            } else if (success === 'breeding') {
                weight = 2; // Successful breeding (higher reward)
            } else if (success === 'failed') {
                weight = -1; // No food found when expected, or failed to breed
            }
            // success === null means neutral move (no special outcome expected)
            
            // Calculate environmental features for generalizable memory
            const relativeElevation = calculateRelativeElevation(worm.head.x, worm.head.y);
            const localTreeDensity = calculateLocalTreeDensity(worm.head.x, worm.head.y);
            const localPixelClass = sampleLocalPixelClass(worm.head.x, worm.head.y);
            
            // Create memory key from environmental features instead of position
            const memoryKey = `${relativeElevation},${localTreeDensity},${localPixelClass},${move.dx},${move.dy}`;
            
            const memoryEntry = {
                relativeElevation: relativeElevation,
                localTreeDensity: localTreeDensity,
                localPixelClass: localPixelClass,
                movement: { dx: move.dx, dy: move.dy },
                weight: weight,
                key: memoryKey,
                kind: success === 'tree' ? 'food'
                    : success === 'breeding' ? 'breed'
                    : 'neutral'
            };
            
            // Check if we already have memory for this environmental context+movement combo
            const existingIndex = worm.memory.findIndex(mem => mem.key === memoryKey);
            
            if (existingIndex !== -1) {
                // Update existing memory weight (accumulate experience)
                worm.memory[existingIndex].weight += weight;
                // Cap weights at reasonable bounds
                worm.memory[existingIndex].weight = Math.max(-5, Math.min(5, worm.memory[existingIndex].weight));
            } else {
                // Add new memory entry
                worm.memory.push(memoryEntry);
            }
            
            // Limit memory size to prevent unlimited growth (keep last 32 memories)
            if (worm.memory.length > 32) {
                worm.memory.shift(); // Remove oldest memory
            }
        }
        
        function hasValidSurface(x, y, options = {}) {
            // Unified surface validation function
            // options: { includeWorms: boolean, excludeOwnBody: worm, supportOnly: boolean }
            const { includeWorms = false, excludeOwnBody = null, supportOnly = false } = options;
            
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const sx = x + dx;
                    const sy = y + dy;
                    if (isValidPos(sx, sy)) {
                        const cell = grid[sy][sx];
                        
                        // Check solid surfaces
                        if (cell === SAND || cell === DIRT || cell === GLASS || 
                            cell === TREE || cell === DEAD_TREE || cell === WATER) {
                            // For support checks, only count surfaces below or adjacent
                            if (supportOnly && sy < y) continue; // Skip surfaces above
                            return true;
                        }
                        
                        // Check worm surfaces if requested
                        if (includeWorms && (cell === INCHWORM || cell === INCHWORM_HEAD || cell === INCHWORM_BODY)) {
                            // If excluding own body, check if this is the worm's own body part
                            if (excludeOwnBody) {
                                const isOwnBodyPart = (sx === excludeOwnBody.head.x && sy === excludeOwnBody.head.y) ||
                                                     (sx === excludeOwnBody.body.x && sy === excludeOwnBody.body.y) ||
                                                     (sx === excludeOwnBody.tail.x && sy === excludeOwnBody.tail.y);
                                if (!isOwnBodyPart) {
                                    if (supportOnly && sy < y) continue; // Skip surfaces above
                                    return true;
                                }
                            } else {
                                if (supportOnly && sy < y) continue; // Skip surfaces above
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
        
        // Tree behavior functions
        function findNearestWater(x, y, maxDistance = 15) {
            let nearest = null;
            let minDistance = Infinity;
            
            for (let checkY = Math.max(0, y - maxDistance); checkY < Math.min(GRID_HEIGHT, y + maxDistance + 1); checkY++) {
                for (let checkX = Math.max(0, x - maxDistance); checkX < Math.min(GRID_WIDTH, x + maxDistance + 1); checkX++) {
                    if (grid[checkY][checkX] === WATER) {
                        // Use squared distance to avoid expensive sqrt calculation
                        const distanceSquared = (checkX - x) * (checkX - x) + (checkY - y) * (checkY - y);
                        if (distanceSquared < minDistance) {
                            minDistance = distanceSquared;
                            nearest = { x: checkX, y: checkY, distance: Math.sqrt(distanceSquared) };
                        }
                    }
                }
            }
            
            return nearest;
        }
        
        function countNearbyTrees(x, y, radius = 3) {
            let count = 0;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    // Only count living trees, not dead trees
                    if (isValidPos(nx, ny) && grid[ny][nx] === TREE) {
                        count++;
                    }
                }
            }
            return count;
        }
        
        function countConnectedPixels(startX, startY, material, grid) {
            // Use flood fill to count connected pixels of the same material
            const visited = new Set();
            const stack = [{ x: startX, y: startY }];
            let count = 0;
            
            while (stack.length > 0) {
                const { x, y } = stack.pop();
                const key = `${x},${y}`;
                
                if (visited.has(key) || !isValidPos(x, y) || grid[y][x] !== material) {
                    continue;
                }
                
                visited.add(key);
                count++;
                
                // Add adjacent cells to stack
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        stack.push({ x: x + dx, y: y + dy });
                    }
                }
                
                // Limit flood fill to prevent performance issues
                if (count > 50) break;
            }
            
            return count;
        }
        
        function updateTreeDecomposition() {
            // Process decomposition every frame
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (grid[y][x] === DEAD_TREE && treeDecompositionGrid[y][x] > 0) {
                        treeDecompositionGrid[y][x]--;
                        
                        // Convert to dirt when decomposition is complete
                        if (treeDecompositionGrid[y][x] <= 0) {
                            grid[y][x] = DIRT;
                        }
                    }
                }
            }
        }
        
        function updateTreeBehavior() {
            // Only update trees every 30 frames for performance
            if (treeUpdateCounter % 30 !== 0) return;
            
            const treesToProcess = [];
            
            // Find all tree positions
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (grid[y][x] === TREE) {
                        treesToProcess.push({ x, y });
                    }
                }
            }
            
            // Process each tree
            for (const tree of treesToProcess) {
                const waterInfo = findNearestWater(tree.x, tree.y);
                const nearbyTreeCount = countNearbyTrees(tree.x, tree.y);
                
                // Trees die only if isolated (1 neighbor) AND network lacks water access
                let adjacentTreeCount = 0;
                const adjacentTrees = [];
                
                // Count directly adjacent trees (1-pixel radius)
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = tree.x + dx;
                        const ny = tree.y + dy;
                        if (isValidPos(nx, ny) && grid[ny][nx] === TREE) {
                            adjacentTreeCount++;
                            adjacentTrees.push({ x: nx, y: ny });
                        }
                    }
                }
                
                // Consider death if tree is isolated (0 neighbors) or end of branch (1 neighbor)
                if (adjacentTreeCount <= 1) {
                    // Check if this tree or its network has water access
                    let networkHasWater = false;
                    
                    // Check if this tree has water access
                    if (waterInfo && waterInfo.distance <= 15) {
                        networkHasWater = true;
                    }
                    
                    // If has a neighbor, check if that neighbor has water access
                    if (!networkHasWater && adjacentTrees.length > 0) {
                        const neighbor = adjacentTrees[0];
                        const neighborWater = findNearestWater(neighbor.x, neighbor.y);
                        if (neighborWater && neighborWater.distance <= 15) {
                            networkHasWater = true;
                        }
                    }
                    
                    // Death rates: isolated trees (0 neighbors) die faster than end branches (1 neighbor)
                    const deathChance = adjacentTreeCount === 0 ? 0.08 : 0.03; // 8% for isolated, 3% for end branches
                    
                    // Only die if isolated/end branch AND no water access in local network
                    if (!networkHasWater && Math.random() < deathChance) {
                        grid[tree.y][tree.x] = DEAD_TREE;
                        treeDecompositionGrid[tree.y][tree.x] = 180;
                        continue;
                    }
                }
                
                // Determine growth behavior based on clustering
                const isClustered = nearbyTreeCount >= 3;
                const growthChance = isClustered ? 0.12 : 0.08; // Higher chance when clustered
                
                // Trees grow toward water or branch when clustered
                if (waterInfo && waterInfo.distance <= 8 && Math.random() < growthChance) {
                    const dx = waterInfo.x - tree.x;
                    const dy = waterInfo.y - tree.y;
                    
                    // Normalize direction
                    const dirX = dx > 0 ? 1 : (dx < 0 ? -1 : 0);
                    const dirY = dy > 0 ? 1 : (dy < 0 ? -1 : 0);
                    
                    const candidates = [];
                    
                    if (isClustered) {
                        // When clustered, prefer branching in multiple directions
                        // Add perpendicular directions to main growth
                        if (dirX !== 0) {
                            candidates.push({ x: tree.x, y: tree.y - 1 }); // Up
                            candidates.push({ x: tree.x, y: tree.y + 1 }); // Down
                        }
                        if (dirY !== 0) {
                            candidates.push({ x: tree.x - 1, y: tree.y }); // Left
                            candidates.push({ x: tree.x + 1, y: tree.y }); // Right
                        }
                        
                        // Also add diagonal branching
                        candidates.push({ x: tree.x + dirX, y: tree.y - 1 });
                        candidates.push({ x: tree.x + dirX, y: tree.y + 1 });
                        candidates.push({ x: tree.x - dirX, y: tree.y - 1 });
                        candidates.push({ x: tree.x - dirX, y: tree.y + 1 });
                        
                        // Still include main direction but with lower priority
                        if (dirX !== 0) candidates.push({ x: tree.x + dirX, y: tree.y });
                        if (dirY !== 0) candidates.push({ x: tree.x, y: tree.y + dirY });
                    } else {
                        // When not clustered, prefer growing toward water
                        if (dirX !== 0) candidates.push({ x: tree.x + dirX, y: tree.y });
                        if (dirY !== 0) candidates.push({ x: tree.x, y: tree.y + dirY });
                        
                        // Add adjacent empty spaces as backup
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                candidates.push({ x: tree.x + dx, y: tree.y + dy });
                            }
                        }
                    }
                    
                    // Shuffle candidates for randomness
                    for (let i = candidates.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
                    }
                    
                    // Try to grow to candidate positions
                    let grownCount = 0;
                    const maxGrowth = isClustered ? (Math.random() < 0.3 ? 2 : 1) : 1; // Sometimes branch twice when clustered
                    
                    for (const candidate of candidates) {
                        if (grownCount >= maxGrowth) break;
                        
                        if (isValidPos(candidate.x, candidate.y)) {
                            const targetCell = grid[candidate.y][candidate.x];
                            
                            // Trees can grow into empty space or through dirt, but not through glass
                            if ((targetCell === EMPTY || targetCell === DIRT) && targetCell !== GLASS) {
                                // Check if this position isn't too crowded
                                const nearbyAtCandidate = countNearbyTrees(candidate.x, candidate.y, 2);
                                if (nearbyAtCandidate < 8) { // Prevent overcrowding (reduced from 6 to allow denser growth)
                                    // Only check for glass adjacency, not tree adjacency
                                    let hasAdjacentGlass = false;
                                    for (let checkDy = -1; checkDy <= 1; checkDy++) {
                                        for (let checkDx = -1; checkDx <= 1; checkDx++) {
                                            const adjX = candidate.x + checkDx;
                                            const adjY = candidate.y + checkDy;
                                            if (isValidPos(adjX, adjY) && grid[adjY][adjX] === GLASS) {
                                                hasAdjacentGlass = true;
                                                break;
                                            }
                                        }
                                        if (hasAdjacentGlass) break;
                                    }
                                    
                                    if (!hasAdjacentGlass) {
                                        grid[candidate.y][candidate.x] = TREE;
                                        grownCount++;
                                    }
                                    
                                    // If growing through dirt, increase growth chance slightly (nutrient bonus)
                                    if (targetCell === DIRT && Math.random() < 0.2 && grownCount < maxGrowth) {
                                        // Bonus growth chance when consuming dirt
                                        continue; // Try to grow one more time
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        function updateSimulation() {
            if (isPaused) return;
            
            // Continuous material placement while mouse is held down
            if (isMouseDown && isValidPos(mouseX, mouseY)) {
                // Add material every few frames for continuous flow
                if (treeUpdateCounter % 1 === 0) { // Every 3 frames
                    addMaterial(mouseX, mouseY, selectedMaterial, brushSize);
                }
            }
            
            // Process generators - add material continuously
            generators.forEach(generator => {
                if (treeUpdateCounter % 3 === 0) { // Every 3 frames for slower generation
                    addMaterial(generator.x, generator.y, generator.material, generator.radius);
                }
            });
            
            // Increment tree update counter
            treeUpdateCounter++;
            
            
            // Process tree growth (fractal growth) - DISABLED during grid processing
            // This will be handled after the new grid is created
            
            // Process tree behavior (movement toward water, death)
            updateTreeBehavior();
            
            // Process worm behavior
            updateWorms();
            
            // Process tree decomposition
            updateTreeDecomposition();
            
            // Get the alternate grid set and clear it for next frame
            let newGrid, newFireLifeGrid, newSteamLifeGrid, newAcidLifeGrid, newLavaLifeGrid, newInchwormLifeGrid, newWaterTintGrid;
            
            if (currentGridSet === 'A') {
                newGrid = gridB;
                newFireLifeGrid = fireLifeGridB;
                newSteamLifeGrid = steamLifeGridB;
                newAcidLifeGrid = acidLifeGridB;
                newLavaLifeGrid = lavaLifeGridB;
                newInchwormLifeGrid = inchwormLifeGridB;
                newWaterTintGrid = waterTintGridB;
            } else {
                newGrid = gridA;
                newFireLifeGrid = fireLifeGridA;
                newSteamLifeGrid = steamLifeGridA;
                newAcidLifeGrid = acidLifeGridA;
                newLavaLifeGrid = lavaLifeGridA;
                newInchwormLifeGrid = inchwormLifeGridA;
                newWaterTintGrid = waterTintGridA;
            }
            
            // Clear the grids
            for (let y = 0; y < GRID_HEIGHT; y++) {
                newGrid[y].fill(EMPTY);
                newFireLifeGrid[y].fill(0);
                newSteamLifeGrid[y].fill(0);
                newAcidLifeGrid[y].fill(0);
                newLavaLifeGrid[y].fill(0);
                newInchwormLifeGrid[y].fill(0);
                newWaterTintGrid[y].fill(0);
            }
            
            let fallingWaterThisFrame = 0;      // reset every frame
            
            // Process from bottom to top, left to right
            for (let y = GRID_HEIGHT - 1; y >= 0; y--) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = grid[y][x];
                    
                    if (cell === EMPTY) continue;
                    
                    // Try to move particle
                    let destX = x, destY = y;
                    
                    // Only isolated tree pixels fall (not connected forest structures)
                    if (cell === TREE && y < GRID_HEIGHT - 1) {
                        // Count adjacent trees to determine if truly isolated
                        let adjacentTreeCount = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValidPos(nx, ny) && grid[ny][nx] === TREE) {
                                    adjacentTreeCount++;
                                }
                            }
                        }
                        
                        // Only isolated tree pixels (0 neighbors) fall
                        if (adjacentTreeCount === 0 && grid[y + 1][x] === EMPTY && Math.random() < 0.5) {
                            // Isolated tree pixel falls down
                            destY = y + 1;
                        }
                        // Try diagonal fall for isolated trees
                        else if (adjacentTreeCount === 0 && Math.random() < 0.3) {
                            const leftDiag = x > 0 ? grid[y + 1][x - 1] : null;
                            const rightDiag = x < GRID_WIDTH - 1 ? grid[y + 1][x + 1] : null;
                            
                            if (leftDiag === EMPTY && rightDiag === EMPTY) {
                                const dir = Math.random() < 0.5 ? -1 : 1;
                                destX = x + dir;
                                destY = y + 1;
                            } else if (leftDiag === EMPTY) {
                                destX = x - 1;
                                destY = y + 1;
                            } else if (rightDiag === EMPTY) {
                                destX = x + 1;
                                destY = y + 1;
                            }
                        }
                    }
                    
                    // Individual worm parts don't move on their own - handled by updateWorms()
                    else if (cell === INCHWORM || cell === INCHWORM_HEAD || cell === INCHWORM_BODY) {
                        // Worm parts are moved by the worm system, just copy them
                        // Individual parts don't have independent physics
                    }
                    
                    // â”€â”€ ACID movement (lighter than water) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    else if (cell === ACID) {
                        // fall into EMPTY
                        if (y < GRID_HEIGHT-1 && grid[y+1][x] === EMPTY) {
                            destY = y + 1;
                        }
                        // sit / slide on WATER surface (don't sink)
                        else if (y < GRID_HEIGHT-1 && grid[y+1][x] === WATER) {
                            // occasional sideways slide along the surface
                            if (Math.random() < 0.6) {
                                const dir = Math.random() < 0.5 ? -1 : 1;
                                const nx = x + dir;
                                if (isValidPos(nx,y) && grid[y][nx] === EMPTY && grid[y][nx] !== GLASS) destX = nx;
                            }
                            // stay put otherwise
                        }
                        // diagonal tumble around obstacles (like water)
                        else if (Math.random() < 0.7) {
                            const leftEmpty  = x>0 && y<GRID_HEIGHT-1 && grid[y+1][x-1] === EMPTY;
                            const rightEmpty = x<GRID_WIDTH-1 && y<GRID_HEIGHT-1 && grid[y+1][x+1] === EMPTY;
                            if (leftEmpty && rightEmpty) {
                                destX = x + (Math.random()<0.5?-1:1); destY = y+1;
                            } else if (leftEmpty) {
                                destX = x-1; destY = y+1;
                            } else if (rightEmpty) {
                                destX = x+1; destY = y+1;
                            }
                        }
                    }
                    
                    // Handle falling for falling materials
                    else if (y < GRID_HEIGHT - 1 && (cell === SAND || cell === DIRT || cell === WATER || cell === LAVA)) {
                        // Water + dirt interaction
                        if (cell === WATER && grid[y + 1][x] === DIRT && Math.random() < 0.02) {
                            // Check if growth path is clear (no glass blocking upward growth)
                            if (y > 0 && grid[y - 1][x] !== GLASS) {
                                // Water hits dirt - both become tree
                                newGrid[y + 1][x] = TREE;
                                startTreeGrowth(x, y);
                                continue; // Water is consumed
                            }
                        }
                        
                        // Check if can fall down (water falls faster by skipping multiple cells)
                        if (cell === WATER && grid[y + 1][x] === EMPTY) {
                            // Water tries to fall multiple cells at once
                            let fallDistance = 1;
                            while (y + fallDistance + 1 < GRID_HEIGHT && 
                                   grid[y + fallDistance + 1][x] === EMPTY && 
                                   fallDistance < 3) { // Max fall distance of 3
                                fallDistance++;
                            }
                            destY = y + fallDistance;
                            fallingWaterThisFrame++;
                        }
                        else if (grid[y + 1][x] === EMPTY) {
                            destY = y + 1;
                        }
                        // Sand and dirt sink through water (density-based)
                        else if ((cell === SAND || cell === DIRT) && grid[y + 1][x] === WATER) {
                            destY = y + 1;
                        }
                        // Try diagonal fall for all falling materials including water
                        else if ((cell === SAND || cell === DIRT || cell === WATER || cell === LAVA) && Math.random() < 0.7) {
                            const leftDiag = x > 0 ? grid[y + 1][x - 1] : null;
                            const rightDiag = x < GRID_WIDTH - 1 ? grid[y + 1][x + 1] : null;
                            
                            // Check what can fall diagonally
                            const canFallLeft = leftDiag === EMPTY || 
                                ((cell === SAND || cell === DIRT) && leftDiag === WATER);
                            const canFallRight = rightDiag === EMPTY || 
                                ((cell === SAND || cell === DIRT) && rightDiag === WATER);
                            
                            if (canFallLeft && canFallRight) {
                                const dir = Math.random() < 0.5 ? -1 : 1;
                                destX = x + dir;
                                destY = y + 1;
                            } else if (canFallLeft) {
                                destX = x - 1;
                                destY = y + 1;
                            } else if (canFallRight) {
                                destX = x + 1;
                                destY = y + 1;
                            }
                        }
                        // Water horizontal flow when blocked (faster spreading)
                        else if (cell === WATER && Math.random() < 0.8) { // Increased from 0.4 to 0.8
                            // Water spreads multiple cells horizontally
                            const directions = [];
                            if (x > 0 && grid[y][x - 1] === EMPTY) directions.push(-1);
                            if (x < GRID_WIDTH - 1 && grid[y][x + 1] === EMPTY) directions.push(1);
                            
                            if (directions.length > 0) {
                                const dir = directions[Math.floor(Math.random() * directions.length)];
                                let spreadDistance = 1;
                                
                                // Try to spread multiple cells at once
                                while (x + (dir * (spreadDistance + 1)) >= 0 && 
                                       x + (dir * (spreadDistance + 1)) < GRID_WIDTH &&
                                       grid[y][x + (dir * (spreadDistance + 1))] === EMPTY && 
                                       spreadDistance < 2) { // Max spread distance of 2
                                    spreadDistance++;
                                }
                                destX = x + (dir * spreadDistance);
                            }
                        }
                        // Lava horizontal flow (slower than water)
                        else if (cell === LAVA && Math.random() < 0.3) {
                            if (x > 0 && grid[y][x - 1] === EMPTY && Math.random() < 0.5) {
                                destX = x - 1;
                            } else if (x < GRID_WIDTH - 1 && grid[y][x + 1] === EMPTY) {
                                destX = x + 1;
                            }
                        }
                    }
                    
                    // Steam rises
                    else if (cell === STEAM && y > 0 && Math.random() < 0.4) {
                        if (grid[y - 1][x] === EMPTY) {
                            destY = y - 1;
                            
                            // Steam also moves horizontally while rising if on glass surface
                            // Check if standing on glass
                            if (y < GRID_HEIGHT - 1 && grid[y + 1][x] === GLASS && Math.random() < 0.5) {
                                // Try to move horizontally while rising
                                const directions = [];
                                if (x > 0 && grid[y - 1][x - 1] === EMPTY) directions.push(-1);
                                if (x < GRID_WIDTH - 1 && grid[y - 1][x + 1] === EMPTY) directions.push(1);
                                
                                if (directions.length > 0) {
                                    const dir = directions[Math.floor(Math.random() * directions.length)];
                                    destX = x + dir;
                                }
                            }
                        }
                        // Steam spreads sideways if can't rise
                        else if (Math.random() < 0.3) {
                            if (x > 0 && grid[y][x - 1] === EMPTY && Math.random() < 0.5) {
                                destX = x - 1;
                            } else if (x < GRID_WIDTH - 1 && grid[y][x + 1] === EMPTY) {
                                destX = x + 1;
                            }
                        }
                    }
                    
                    // Fire rises slightly
                    else if (cell === FIRE && y > 0 && Math.random() < 0.1) {
                        if (grid[y - 1][x] === EMPTY) {
                            destY = y - 1;
                        }
                    }
                    
                    // Place particle in destination
                    const destContent = newGrid[destY][destX];
                    
                    // Check if can displace what's at destination
                    const canDisplace = destContent === EMPTY || 
                        ((cell === SAND || cell === DIRT) && destContent === WATER);
                    
                    if (canDisplace) {
                        newGrid[destY][destX] = cell;
                        
                        // If displacing water, place it at original position
                        if (destContent === WATER && newGrid[y][x] === EMPTY) {
                            newGrid[y][x] = WATER;
                        }
                        
                        // Copy life values
                        if (cell === FIRE) {
                            const newLife = Math.max(0, fireLifeGrid[y][x] - 1);
                            if (newLife > 0) {
                                newFireLifeGrid[destY][destX] = newLife;
                            } else {
                                newGrid[destY][destX] = EMPTY; // Fire dies
                            }
                        } else if (cell === STEAM) {
                            const newLife = Math.max(0, steamLifeGrid[y][x] - 1);
                            if (newLife > 0) {
                                newSteamLifeGrid[destY][destX] = newLife;
                            } else {
                                newGrid[destY][destX] = EMPTY; // Steam dissipates
                            }
                        } else if (cell === ACID) {
                            const newLife = Math.max(0, acidLifeGrid[y][x] - 1);
                            if (newLife > 0) {
                                newAcidLifeGrid[destY][destX] = newLife;
                            } else {
                                newGrid[destY][destX] = EMPTY; // Acid evaporates
                            }
                        } else if (cell === INCHWORM || cell === INCHWORM_HEAD || cell === INCHWORM_BODY) {
                            // Worm parts don't age individually - handled by worm system
                            newInchwormLifeGrid[destY][destX] = inchwormLifeGrid[y][x];
                        }
                    } else {
                        // Can't displace, try to place in original position
                        if (newGrid[y][x] === EMPTY) {
                            newGrid[y][x] = cell;
                            // Copy life values to original position
                            if (cell === FIRE) newFireLifeGrid[y][x] = fireLifeGrid[y][x];
                            if (cell === STEAM) newSteamLifeGrid[y][x] = steamLifeGrid[y][x];
                            if (cell === ACID) newAcidLifeGrid[y][x] = acidLifeGrid[y][x];
                            if (cell === INCHWORM || cell === INCHWORM_HEAD || cell === INCHWORM_BODY) {
                                newInchwormLifeGrid[y][x] = inchwormLifeGrid[y][x];
                            }
                        }
                    }
                }
            }
            
            // Second pass: Handle interactions and transformations
            let splashTriggered = false;
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = newGrid[y][x];
                    
                    // Fire interactions
                    if (cell === FIRE) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValidPos(nx, ny)) {
                                    const neighbor = newGrid[ny][nx];
                                    
                                    // Fire spreads to flammable materials (trees and dead trees)
                                    if (materials[neighbor]?.flammable && Math.random() < 0.05) {
                                        newGrid[ny][nx] = FIRE;
                                        newFireLifeGrid[ny][nx] = materials[FIRE].life;
                                        // Clear decomposition timer if burning dead tree
                                        if (neighbor === DEAD_TREE) {
                                            treeDecompositionGrid[ny][nx] = 0;
                                        }
                                        
                                        // Create steam when plants burn (moisture release)
                                        if (neighbor === TREE || neighbor === DEAD_TREE) {
                                            // Try to place steam in nearby empty spaces
                                            let steamCreated = false;
                                            for (let steamDy = -1; steamDy <= 1 && !steamCreated; steamDy++) {
                                                for (let steamDx = -1; steamDx <= 1 && !steamCreated; steamDx++) {
                                                    const steamX = nx + steamDx;
                                                    const steamY = ny + steamDy;
                                                    if (isValidPos(steamX, steamY) && 
                                                        newGrid[steamY][steamX] === EMPTY && 
                                                        Math.random() < 0.3) {
                                                        newGrid[steamY][steamX] = STEAM;
                                                        newSteamLifeGrid[steamY][steamX] = materials[STEAM].life;
                                                        steamCreated = true;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    // Fire turns sand to glass
                                    else if (neighbor === SAND && Math.random() < 0.02) {
                                        newGrid[ny][nx] = GLASS;
                                    }
                                    // Fire turns water to steam
                                    else if (neighbor === WATER && Math.random() < 0.08) {
                                        newGrid[ny][nx] = STEAM;
                                        newSteamLifeGrid[ny][nx] = materials[STEAM].life;
                                        if (!splashTriggered) {
                                            triggerSplashAccent(2, null, 'steamHiss'); // Fire + water = medium splash
                                            splashTriggered = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // Water interactions
                    else if (cell === WATER) {
                        // Water extinguishes fire
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValidPos(nx, ny) && newGrid[ny][nx] === FIRE && Math.random() < 0.3) {
                                    newGrid[ny][nx] = EMPTY;
                                    newFireLifeGrid[ny][nx] = 0;
                                    if (!splashTriggered) {
                                        triggerSplashAccent(3, null, 'steamHiss'); // Water extinguishing fire = big splash
                                        splashTriggered = true;
                                    }
                                }
                            }
                        }
                        
                    }
                    
                    // Dirt interactions
                    else if (cell === DIRT) {
                        // Check for neighboring water to sprout trees
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue; // Skip self
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValidPos(nx, ny) && newGrid[ny][nx] === WATER && Math.random() < 0.008) {
                                    // Check if growth path is clear (no glass blocking upward growth)
                                    const growthY = y - 1;
                                    if (isValidPos(x, growthY) && newGrid[growthY][x] !== GLASS) {
                                        // Convert dirt to tree and consume water
                                        newGrid[y][x] = TREE;
                                        newGrid[ny][nx] = EMPTY; // Consume the water
                                        startTreeGrowth(x, growthY); // Start fractal growth upward
                                        if (!splashTriggered) {
                                            triggerSplashAccent(1, null, 'waterDrop'); // Water + dirt = small splash
                                            splashTriggered = true;
                                        }
                                        
                                        break; // Only one tree per dirt particle
                                    }
                                }
                            }
                        }
                    }
                    
                    
                    // Water, dirt, and tree interactions (inchworm spawning)
                    else if (cell === WATER || cell === DIRT || cell === TREE) {
                        // Check if water, dirt, and tree are all touching
                        let hasWater = false, hasDirt = false, hasTree = false;
                        
                        // Check adjacent cells for the other two materials
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValidPos(nx, ny)) {
                                    const neighbor = newGrid[ny][nx];
                                    if (neighbor === WATER) hasWater = true;
                                    if (neighbor === DIRT) hasDirt = true;
                                    if (neighbor === TREE) hasTree = true;
                                }
                            }
                        }
                        
                        // Only proceed if all three materials are touching
                        if (hasWater && hasDirt && hasTree) {
                            // Count connected pixels of current material type using flood fill
                            const connectedCount = countConnectedPixels(x, y, cell, newGrid);
                            
                            // Spawn inchworm if more than 4 connected pixels of this type
                            if (connectedCount > 4 && Math.random() < 0.005) {
                                // Find an empty adjacent spot to spawn inchworm
                                const spawnCandidates = [];
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dx = -1; dx <= 1; dx++) {
                                        if (dx === 0 && dy === 0) continue;
                                        const nx = x + dx;
                                        const ny = y + dy;
                                        if (isValidPos(nx, ny) && newGrid[ny][nx] === EMPTY) {
                                            spawnCandidates.push({ x: nx, y: ny });
                                        }
                                    }
                                }
                                
                                if (spawnCandidates.length >= 3) {
                                    // Spawn a 3-pixel worm
                                    spawnThreePixelWorm(spawnCandidates, newGrid, newInchwormLifeGrid);
                                }
                            }
                        }
                    }
                    
                    // Steam interactions
                    else if (cell === STEAM) {
                        // Steam condenses to water when touching glass
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValidPos(nx, ny) && newGrid[ny][nx] === GLASS && Math.random() < 0.15) {
                                    // Convert steam to water
                                    newGrid[y][x] = WATER;
                                    newSteamLifeGrid[y][x] = 0; // Clear steam life
                                    break; // Only one conversion per steam particle
                                }
                            }
                        }
                    }
                                        
                    /* â”€â”€ ACID â†” WATER dilution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
                    else if (cell === ACID) {
                        const lifeHere = newAcidLifeGrid[y][x];

                        /* count water neighbours */
                        let waterNbrs = 0, totalNbrs = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nx = x + dx, ny = y + dy;
                                if (!isValidPos(nx, ny)) continue;

                                totalNbrs++;
                                if (newGrid[ny][nx] === WATER) {
                                    waterNbrs++;
                                    /* only tint water above or to the sides (floating contamination) */
                                    if (dy <= 0) { // up or horizontal, not down
                                        newWaterTintGrid[ny][nx] = 15;     // start as subtle blend, not full intensity
                                    }
                                }
                            }
                        }

                        /* weaken this acid pixel only if water is the majority */
                        let remaining = lifeHere;
                        if (waterNbrs > totalNbrs / 0.5) {
                            const decay = waterNbrs * 2;              // tweak to taste
                            remaining = lifeHere - decay;
                        }

                        remaining = Math.max(0, remaining);
                        newAcidLifeGrid[y][x] = remaining;
                        if (remaining === 0) {
                            /* fully neutralised â†’ becomes normal water */
                            newGrid[y][x] = WATER;
                            newWaterTintGrid[y][x] = 5;              // slight tint residue
                            if (!splashTriggered) {
                                triggerSplashAccent(1.5, null, 'acidFizz'); // Acid neutralization modulation
                                splashTriggered = true;
                            }
                        }

                        // â”€â”€ Corrosion (unchanged; never attacks WATER) â”€â”€â”€â”€â”€â”€â”€â”€â”€
                        for (let dy=-1; dy<=1; dy++){
                            for (let dx=-1; dx<=1; dx++){
                                if (dx===0 && dy===0) continue;
                                const nx = x+dx, ny = y+dy;
                                if (!isValidPos(nx,ny)) continue;
                                const n = newGrid[ny][nx];
                                if (n===EMPTY || n===WATER || n===ACID || n===GLASS) continue;
                                if (Math.random() < 0.03) newGrid[ny][nx] = EMPTY;   // dissolve
                            }
                        }
                    }

                    
                    // Lava interactions
                    else if (cell === LAVA) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValidPos(nx, ny)) {
                                    const neighbor = newGrid[ny][nx];
                                    
                                    // Lava burns flammable materials
                                    if (materials[neighbor]?.flammable && Math.random() < 0.1) {
                                        newGrid[ny][nx] = FIRE;
                                        newFireLifeGrid[ny][nx] = materials[FIRE].life;
                                        if (neighbor === DEAD_TREE) {
                                            treeDecompositionGrid[ny][nx] = 0;
                                        }
                                    }
                                    // Lava turns water to steam instantly
                                    else if (neighbor === WATER && Math.random() < 0.2) {
                                        newGrid[ny][nx] = STEAM;
                                        newSteamLifeGrid[ny][nx] = materials[STEAM].life;
                                        if (!splashTriggered) {
                                            triggerSplashAccent(2.5, null, 'lavaBloop'); // Lava vaporizing water
                                            splashTriggered = true;
                                        }
                                    }
                                    // Lava melts sand to glass
                                    else if (neighbor === SAND && Math.random() < 0.05) {
                                        newGrid[ny][nx] = GLASS;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Swap to the new grid set
            grid = newGrid;
            fireLifeGrid = newFireLifeGrid;
            steamLifeGrid = newSteamLifeGrid;
            acidLifeGrid = newAcidLifeGrid;
            lavaLifeGrid = newLavaLifeGrid;
            inchwormLifeGrid = newInchwormLifeGrid;
            waterTintGrid = newWaterTintGrid;
            
            // Toggle the current grid set
            currentGridSet = currentGridSet === 'A' ? 'B' : 'A';
            
            // Update water noise based on movement every 10 frames
            if (treeUpdateCounter % 10 === 0) {
                updateWaterNoise(fallingWaterThisFrame);
            }
            
            // Process water tint diffusion (lazy floating spread)
            const tintGrid = currentGridSet === 'A' ? waterTintGridA : waterTintGridB;
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (grid[y][x] === WATER && tintGrid[y][x] > 8) {
                        if (Math.random() < 0.3) { // probabilistic spreading
                            const spreadTint = Math.floor(tintGrid[y][x] * 0.4);
                            const directions = [
                                {dx: -1, dy: 0}, // left
                                {dx: 1, dy: 0},  // right
                                {dx: 0, dy: -1}  // up
                            ];
                            
                            for (const dir of directions) {
                                const nx = x + dir.dx, ny = y + dir.dy;
                                if (isValidPos(nx, ny) && grid[ny][nx] === WATER) {
                                    if (tintGrid[ny][nx] < spreadTint) {
                                        tintGrid[ny][nx] = spreadTint;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Process fractal tree growth
            const fractalGrid = grid.map(row => [...row]);
            
            for (let i = treeGrowthQueue.length - 1; i >= 0; i--) {
                const treeNode = treeGrowthQueue[i];
                if (!growFractalTree(treeNode, fractalGrid)) {
                    treeGrowthQueue.splice(i, 1);
                }
            }
            
            // Copy fractal results back to main grid
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (fractalGrid[y][x] === TREE && grid[y][x] === EMPTY) {
                        grid[y][x] = TREE;
                    }
                }
            }
            
        }
        
        function renderGrid() {
            // Clear image data
            for (let i = 0; i < imageData.data.length; i += 4) {
                imageData.data[i] = 0;     // R
                imageData.data[i + 1] = 0; // G
                imageData.data[i + 2] = 0; // B
                imageData.data[i + 3] = 255; // A
            }
            
            // Draw grid to image data
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = grid[y][x];
                    if (cell !== EMPTY) {
                        const index = (y * GRID_WIDTH + x) * 4;
                        let color = getPixelColor(cell, x, y);   // pass x,y so worm code can pick a variant
                        
                        // Modify fire color based on life
                        if (cell === FIRE) {
                            const lifeRatio = fireLifeGrid[y][x] / materials[FIRE].life;
                            color = [
                                Math.floor(color[0] * lifeRatio),
                                Math.floor(color[1] * lifeRatio),
                                Math.floor(color[2] * lifeRatio),
                                255
                            ];
                        }
                        // Modify steam opacity based on life
                        else if (cell === STEAM) {
                            const lifeRatio = steamLifeGrid[y][x] / materials[STEAM].life;
                            color = [
                                color[0],
                                color[1],
                                color[2],
                                Math.floor(color[3] * lifeRatio)
                            ];
                        }
                        // Modify acid intensity based on life
                        else if (cell === ACID) {
                        let lifeRatio = acidLifeGrid[y][x] / materials[ACID].life;   // 0â€‘1
                        // keep at least 0.4 brightness, fade only the upper 60â€¯%
                        const brightness = 0.8 + 0.6 * lifeRatio;                    // 0.4â€‘1
                        color = [
                            Math.floor(color[0] * brightness),
                            Math.floor(color[1] * brightness),
                            Math.floor(color[2] * brightness),
                            255
                        ];
                        }
                        // Water tint fades if the timer is running
                        else if (cell === WATER) {
                            const currentTintGrid = (currentGridSet==='A' ? waterTintGridA : waterTintGridB);
                            const tint = currentTintGrid[y][x];
                            if (tint > 1) {
                                // blend base blue (r,g,b) with acidâ€‘green (50,255,50)
                                const mix = tint / 40;                   // same constant used above
                                color = [
                                    Math.round(color[0]*(1-mix) + 50*mix),
                                    Math.round(color[1]*(1-mix) + 255*mix),
                                    Math.round(color[2]*(1-mix) + 50*mix),
                                    255
                                ];
                                // fade the timer
                                currentTintGrid[y][x] = tint-1;
                            }
                        }
                        
                        imageData.data[index] = color[0];     // R
                        imageData.data[index + 1] = color[1]; // G
                        imageData.data[index + 2] = color[2]; // B
                        imageData.data[index + 3] = color[3]; // A
                    }
                }
            }
            
            // Use reusable temporary canvas for the pixel data
            tempCtx.putImageData(imageData, 0, 0);
            
            // Scale up to main canvas
            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempCanvas, 0, 0, GRID_WIDTH, GRID_HEIGHT, 0, 0, canvas.width, canvas.height);
            
            // Draw generator indicators on top (only when hovering)
            generators.forEach(generator => {
                // Check if mouse is hovering over this generator
                const isHovering = Math.abs(mouseX - generator.x) <= generator.radius + 1 && 
                                 Math.abs(mouseY - generator.y) <= generator.radius + 1;
                
                if (isHovering) {
                    const screenX = generator.x * CELL_SIZE;
                    const screenY = generator.y * CELL_SIZE;
                    
                    // Draw a pulsing border around generators
                    const pulse = Math.sin(Date.now() * 0.005) * 0.5 + 0.5; // 0 to 1
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 + pulse * 0.5})`;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(
                        screenX - generator.radius * CELL_SIZE, 
                        screenY - generator.radius * CELL_SIZE,
                        (generator.radius * 2 + 1) * CELL_SIZE,
                        (generator.radius * 2 + 1) * CELL_SIZE
                    );
                }
            });
        }
        
        function clearGrid() {
            initializeGrids();
            treeGrowthQueue = [];
            generators = [];
            treeUpdateCounter = 0;
        }
        
        function resizeCanvas() {
            const { width: viewportWidth, height: viewportHeight } = getViewportDimensions();
            const newGridWidth = Math.floor(viewportWidth / CELL_SIZE);
            const newGridHeight = Math.floor(viewportHeight / CELL_SIZE);
            
            // Only resize if dimensions actually changed
            if (newGridWidth !== GRID_WIDTH || newGridHeight !== GRID_HEIGHT) {
                // Store old grid data
                const oldGrid = grid;
                const oldFireLife = fireLifeGrid;
                const oldSteamLife = steamLifeGrid;
                const oldAcidLife = acidLifeGrid;
                const oldLavaLife = lavaLifeGrid;
                const oldInchwormLife = inchwormLifeGrid;
                const oldTreeDecomp = treeDecompositionGrid;
                const oldColorCache = colorCache;
                const oldWidth = GRID_WIDTH;
                const oldHeight = GRID_HEIGHT;
                
                // Update dimensions
                GRID_WIDTH = newGridWidth;
                GRID_HEIGHT = newGridHeight;
                canvas.width = GRID_WIDTH * CELL_SIZE;
                canvas.height = GRID_HEIGHT * CELL_SIZE;
                
                // Store current grid set before reinitializing
                const oldCurrentGridSet = currentGridSet;
                
                // Initialize new grids
                initializeGrids();
                
                // Restore the current grid set
                currentGridSet = oldCurrentGridSet;
                
                // Copy over existing data if possible
                if (oldGrid) {
                    const copyWidth = Math.min(oldWidth, GRID_WIDTH);
                    const copyHeight = Math.min(oldHeight, GRID_HEIGHT);
                    
                    for (let y = 0; y < copyHeight; y++) {
                        for (let x = 0; x < copyWidth; x++) {
                            // Copy to both grid sets to maintain double buffer consistency
                            gridA[y][x] = oldGrid[y][x];
                            gridB[y][x] = oldGrid[y][x];
                            fireLifeGridA[y][x] = oldFireLife[y][x];
                            fireLifeGridB[y][x] = oldFireLife[y][x];
                            steamLifeGridA[y][x] = oldSteamLife[y][x];
                            steamLifeGridB[y][x] = oldSteamLife[y][x];
                            acidLifeGridA[y][x] = oldAcidLife[y][x];
                            acidLifeGridB[y][x] = oldAcidLife[y][x];
                            lavaLifeGridA[y][x] = oldLavaLife[y][x];
                            lavaLifeGridB[y][x] = oldLavaLife[y][x];
                            inchwormLifeGridA[y][x] = oldInchwormLife[y][x];
                            inchwormLifeGridB[y][x] = oldInchwormLife[y][x];
                            treeDecompositionGrid[y][x] = oldTreeDecomp[y][x];
                            colorCache[y][x] = oldColorCache[y][x];
                        }
                    }
                    
                    // Set current grid pointers to the correct set
                    if (currentGridSet === 'A') {
                        grid = gridA;
                        fireLifeGrid = fireLifeGridA;
                        steamLifeGrid = steamLifeGridA;
                        acidLifeGrid = acidLifeGridA;
                        lavaLifeGrid = lavaLifeGridA;
                        inchwormLifeGrid = inchwormLifeGridA;
                    } else {
                        grid = gridB;
                        fireLifeGrid = fireLifeGridB;
                        steamLifeGrid = steamLifeGridB;
                        acidLifeGrid = acidLifeGridB;
                        lavaLifeGrid = lavaLifeGridB;
                        inchwormLifeGrid = inchwormLifeGridB;
                    }
                }
            }
        }
        
        function togglePause() {
            isPaused = !isPaused;
            const pauseButton = document.querySelector('[onclick="togglePause()"]');
            pauseButton.textContent = isPaused ? 'â–¶' : 'â– ';
            
            // Immediately trigger audio update when pausing
            if (isPaused) {
                updateWaterNoise(0); // Force stop when pausing
            }
        }
        
        function toggleMenu() {
            const toggleableElements = document.querySelectorAll('.toggleable');
            const isCollapsed = toggleableElements[0].style.display === 'none';
            
            toggleableElements.forEach(element => {
                element.style.display = isCollapsed ? 'flex' : 'none';
            });
        }
        
        function increaseBrushSize() {
            brushSize = Math.min(brushSize + 1, 10); // Cap at 10
            document.getElementById('brushSizeDisplay').textContent = brushSize;
        }
        
        function decreaseBrushSize() {
            brushSize = Math.max(brushSize - 1, 1); // Min size 1
            document.getElementById('brushSizeDisplay').textContent = brushSize;
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            const soundButton = document.getElementById('soundToggle');
            
            if (soundEnabled) {
                master.gain.value = 0.4; // Restore volume
                soundButton.textContent = 'â™ª';
                soundButton.style.background = '#444';
            } else {
                master.gain.value = 0; // Mute
                soundButton.textContent = 'Ã—';
                soundButton.style.background = '#666';
            }
        }
        
        
        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            unlockAudio();
            isMouseDown = true;
            const pos = getGridPos(e.clientX, e.clientY);
            mouseX = pos.x;
            mouseY = pos.y;
            
            if (selectedMaterial === ERASER) {
                // Remove generator at this position
                generators = generators.filter(gen => 
                    Math.abs(gen.x - pos.x) > 2 || Math.abs(gen.y - pos.y) > 2
                );
            }
            
            addMaterial(mouseX, mouseY, selectedMaterial, brushSize);
        });
        
        canvas.addEventListener('dblclick', (e) => {
            const pos = getGridPos(e.clientX, e.clientY);
            
            if (selectedMaterial !== ERASER) {
                // Add generator at this position
                generators.push({
                    x: pos.x,
                    y: pos.y,
                    material: selectedMaterial,
                    radius: brushSize
                });
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const pos = getGridPos(e.clientX, e.clientY);
            mouseX = pos.x;
            mouseY = pos.y;
            if (isMouseDown) {
                addMaterial(mouseX, mouseY, selectedMaterial, brushSize);
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });
        
        // Touch events for mobile support
        canvas.addEventListener('touchstart', (e) => {
            unlockAudio();
            e.preventDefault(); // Prevent scrolling and other default behaviors
            isMouseDown = true;
            const touch = e.touches[0];
            const pos = getGridPos(touch.clientX, touch.clientY);
            mouseX = pos.x;
            mouseY = pos.y;
            addMaterial(mouseX, mouseY, selectedMaterial, brushSize);
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling
            const touch = e.touches[0];
            const pos = getGridPos(touch.clientX, touch.clientY);
            mouseX = pos.x;
            mouseY = pos.y;
            if (isMouseDown) {
                addMaterial(mouseX, mouseY, selectedMaterial, brushSize);
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isMouseDown = false;
        });
        
        canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            isMouseDown = false;
        });
        
        // Keyboard events
        document.addEventListener('keydown', (e) => {
            unlockAudio();
            if (e.code === 'Space') {
                e.preventDefault();
                togglePause();
            }
        });
        
        // Window resize event
        window.addEventListener('resize', resizeCanvas);
        
        // Visual viewport resize event for mobile Safari
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', resizeCanvas);
        }
        
        // Initial resize to set proper size
        resizeCanvas();
        
        // Image mapping system
        const materialPalette = {
            [SAND]: [220, 184, 112],
            [WATER]: [74, 144, 226],
            [FIRE]: [255, 107, 53],
            [DIRT]: [139, 69, 19],
            [TREE]: [34, 139, 34],
            [GLASS]: [180, 220, 240],
            [STEAM]: [240, 240, 240],
            [ACID]: [50, 255, 50],
            [LAVA]: [255, 69, 0],
            [EMPTY]: [0, 0, 0]
        };
        
        // Calculate color distance using RGB
        function colorDistance(rgb1, rgb2) {
            const dr = rgb1[0] - rgb2[0];
            const dg = rgb1[1] - rgb2[1];
            const db = rgb1[2] - rgb2[2];
            return Math.sqrt(dr * dr + dg * dg + db * db);
        }
        
        // Find closest material for a given RGB color
        function findClosestMaterial(rgb) {
            let closestMaterial = SAND;
            let closestDistance = Infinity;
            
            for (const [material, color] of Object.entries(materialPalette)) {
                const distance = colorDistance(rgb, color);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestMaterial = parseInt(material);
                }
            }
            
            return closestMaterial;
        }
        
        // Floyd-Steinberg dithering
        function ditherImage(imageData, width, height) {
            const data = new Uint8ClampedArray(imageData.data);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const oldR = data[idx];
                    const oldG = data[idx + 1];
                    const oldB = data[idx + 2];
                    
                    // Find closest material color
                    const material = findClosestMaterial([oldR, oldG, oldB]);
                    const newColor = materialPalette[material];
                    
                    // Set new color
                    data[idx] = newColor[0];
                    data[idx + 1] = newColor[1];
                    data[idx + 2] = newColor[2];
                    
                    // Calculate error
                    const errR = oldR - newColor[0];
                    const errG = oldG - newColor[1];
                    const errB = oldB - newColor[2];
                    
                    // Distribute error to neighboring pixels
                    const distributeError = (dx, dy, factor) => {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const nIdx = (ny * width + nx) * 4;
                            data[nIdx] += errR * factor;
                            data[nIdx + 1] += errG * factor;
                            data[nIdx + 2] += errB * factor;
                        }
                    };
                    
                    distributeError(1, 0, 7/16);
                    distributeError(-1, 1, 3/16);
                    distributeError(0, 1, 5/16);
                    distributeError(1, 1, 1/16);
                }
            }
            
            return new ImageData(data, width, height);
        }
        
        // Map image to canvas (1:1 mapping, image already stretched)
        function mapImageToCanvas(imageData, startX = 0, startY = 0) {
            const { width, height } = imageData;
            const data = imageData.data;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const srcIdx = (y * width + x) * 4;
                    
                    const r = data[srcIdx];
                    const g = data[srcIdx + 1];
                    const b = data[srcIdx + 2];
                    const a = data[srcIdx + 3];
                    
                    // Skip transparent pixels
                    if (a < 128) continue;
                    
                    const gridX = startX + x;
                    const gridY = startY + y;
                    
                    if (gridX >= 0 && gridX < GRID_WIDTH && gridY >= 0 && gridY < GRID_HEIGHT) {
                        const material = findClosestMaterial([r, g, b]);
                        grid[gridY][gridX] = material;
                        
                        // Clear color cache for this pixel
                        clearColorCache(gridX, gridY);
                    }
                }
            }
        }
        
        // Loading indicator using pause button
        const loadingIcons = ['â†º', 'â†»', 'â†·', 'â†¶'];
        let loadingIconIndex = 0;
        let loadingInterval = null;
        
        function showLoading() {
            const pauseBtn = document.querySelector('[onclick="togglePause()"]');
            if (pauseBtn) {
                loadingIconIndex = 0;
                pauseBtn.textContent = loadingIcons[loadingIconIndex];
                loadingInterval = setInterval(() => {
                    loadingIconIndex = (loadingIconIndex + 1) % loadingIcons.length;
                    pauseBtn.textContent = loadingIcons[loadingIconIndex];
                }, 200);
            }
        }
        
        function hideLoading() {
            const pauseBtn = document.querySelector('[onclick="togglePause()"]');
            if (pauseBtn) {
                clearInterval(loadingInterval);
                pauseBtn.textContent = isPaused ? 'â–¶' : 'â– ';
            }
        }
        
        // Ctrl+V clipboard paste handler
        document.addEventListener('paste', function(e) {
            const items = e.clipboardData.items;
            
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                
                if (item.type.indexOf('image') !== -1) {
                    const file = item.getAsFile();
                    const reader = new FileReader();
                    
                    showLoading();
                    
                    reader.onload = function(event) {
                        const img = new Image();
                        img.onload = function() {
                            // Get current canvas dimensions
                            const { width: viewportWidth, height: viewportHeight } = getViewportDimensions();
                            const canvasWidth = Math.floor(viewportWidth / CELL_SIZE);
                            const canvasHeight = Math.floor(viewportHeight / CELL_SIZE);
                            
                            // Create canvas to stretch image to canvas aspect ratio
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCanvas.width = canvasWidth;
                            tempCanvas.height = canvasHeight;
                            
                            // Stretch image to fill canvas dimensions
                            tempCtx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                            const imageData = tempCtx.getImageData(0, 0, canvasWidth, canvasHeight);
                            
                            // Apply dithering
                            const ditheredData = ditherImage(imageData, canvasWidth, canvasHeight);
                            
                            // Map to canvas (now 1:1 mapping)
                            mapImageToCanvas(ditheredData);
                            
                            hideLoading();
                        };
                        img.src = event.target.result;
                    };
                    
                    reader.readAsDataURL(file);
                    break;
                }
            }
        });
        
        // Main game loop
        function gameLoop() {
            updateSimulation();
            renderGrid();
            requestAnimationFrame(gameLoop);
        }
        
        // Start the simulation
        gameLoop();
    </script>
</body>
</html>
