<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixelgrid Sand Simulation</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
        }
        canvas { 
            display: block; 
            image-rendering: pixelated;
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
            background: #333;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background: #555;
        }
        #swatch {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .material-btn {
            width: 80px;
            height: 30px;
            border: 2px solid #666;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        .material-btn.selected {
            border-color: #fff;
            box-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>
    <div id="controls">
        <div>Click and drag to add materials</div>
        <button onclick="clearGrid()">Clear</button>
        <button onclick="togglePause()">[SPACE] Pause</button>
    </div>
    <div id="swatch">
        <div class="material-btn selected" onclick="selectMaterial('SAND')" style="background: #dcb870; color: #000;">SAND</div>
        <div class="material-btn" onclick="selectMaterial('WATER')" style="background: #4a90e2; color: #fff;">WATER</div>
        <div class="material-btn" onclick="selectMaterial('FIRE')" style="background: #ff6b35; color: #fff;">FIRE</div>
        <div class="material-btn" onclick="selectMaterial('DIRT')" style="background: #8b4513; color: #fff;">DIRT</div>
        <div class="material-btn" onclick="selectMaterial('TREE')" style="background: #228b22; color: #fff;">TREE</div>
        <div class="material-btn" onclick="selectMaterial('GLASS')" style="background: #b4dcf0; color: #000;">GLASS</div>
        <div class="material-btn" onclick="selectMaterial('STEAM')" style="background: #f0f0f0; color: #000;">STEAM</div>
        <div class="material-btn" onclick="selectMaterial('ACID')" style="background: #32ff32; color: #000;">ACID</div>
        <div class="material-btn" onclick="selectMaterial('ERASER')" style="background: #ff64ff; color: #000;">ERASER</div>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Grid settings - dynamically sized to browser window
        const CELL_SIZE = 3;
        let GRID_WIDTH = Math.floor(window.innerWidth / CELL_SIZE);
        let GRID_HEIGHT = Math.floor(window.innerHeight / CELL_SIZE);
        
        canvas.width = GRID_WIDTH * CELL_SIZE;
        canvas.height = GRID_HEIGHT * CELL_SIZE;
        
        // Material types
        const EMPTY = 0;
        const SAND = 1;
        const WATER = 2;
        const FIRE = 3;
        const DIRT = 4;
        const TREE = 5;
        const GLASS = 6;
        const STEAM = 7;
        const ACID = 8;
        const ERASER = 9;
        
        // Current selected material
        let selectedMaterial = SAND;
        
        // Material properties
        const materials = {
            [EMPTY]: { density: 0, flammable: false, liquid: false },
            [SAND]: { density: 3, flammable: false, liquid: false },
            [WATER]: { density: 2, flammable: false, liquid: true },
            [FIRE]: { density: 1, flammable: false, liquid: false, life: 60 },
            [DIRT]: { density: 4, flammable: false, liquid: false },
            [TREE]: { density: 5, flammable: true, liquid: false },
            [GLASS]: { density: 4, flammable: false, liquid: false },
            [STEAM]: { density: 0.5, flammable: false, liquid: false, life: 120 },
            [ACID]: { density: 2.5, flammable: false, liquid: true, life: 300 },
            [ERASER]: { density: 1, flammable: false, liquid: false }
        };
        
        // Colors for each material
        const materialColors = {
            [EMPTY]: [[0, 0, 0, 255]],
            [SAND]: [
                [220, 184, 112, 255],
                [210, 174, 102, 255],
                [200, 164, 92, 255],
                [190, 154, 82, 255]
            ],
            [WATER]: [
                [74, 144, 226, 255],
                [64, 134, 216, 255],
                [84, 154, 236, 255],
                [54, 124, 206, 255]
            ],
            [FIRE]: [
                [255, 107, 53, 255],
                [255, 140, 0, 255],
                [255, 69, 0, 255],
                [255, 165, 0, 255]
            ],
            [DIRT]: [
                [139, 69, 19, 255],
                [160, 82, 45, 255],
                [101, 67, 33, 255],
                [120, 75, 25, 255]
            ],
            [TREE]: [
                [34, 139, 34, 255],
                [46, 125, 50, 255],
                [56, 142, 60, 255],
                [27, 94, 32, 255]
            ],
            [GLASS]: [
                [180, 220, 240, 200],
                [170, 210, 230, 200],
                [190, 230, 250, 200],
                [160, 200, 220, 200]
            ],
            [STEAM]: [
                [240, 240, 240, 150],
                [230, 230, 230, 140],
                [250, 250, 250, 160],
                [220, 220, 220, 130]
            ],
            [ACID]: [
                [50, 255, 50, 255],
                [40, 245, 40, 255],
                [60, 255, 60, 255],
                [30, 235, 30, 255]
            ],
            [ERASER]: [
                [255, 100, 255, 255],
                [245, 90, 245, 255],
                [255, 110, 255, 255],
                [235, 80, 235, 255]
            ]
        };
        
        // Grid and image data
        let grid, fireLifeGrid, steamLifeGrid, acidLifeGrid, imageData;
        let treeGrowthQueue = []; // Queue for tree growth patterns
        
        function initializeGrids() {
            grid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(EMPTY));
            fireLifeGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            steamLifeGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            acidLifeGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            imageData = ctx.createImageData(GRID_WIDTH, GRID_HEIGHT);
        }
        
        initializeGrids();
        
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let isPaused = false;
        
        function getRandomColor(material) {
            const colors = materialColors[material];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        function selectMaterial(materialName) {
            const materialMap = { SAND, WATER, FIRE, DIRT, TREE, GLASS, STEAM, ACID, ERASER };
            selectedMaterial = materialMap[materialName];
            
            // Update UI
            document.querySelectorAll('.material-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');
        }
        
        function getGridPos(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((clientX - rect.left) / CELL_SIZE);
            const y = Math.floor((clientY - rect.top) / CELL_SIZE);
            return { x, y };
        }
        
        function isValidPos(x, y) {
            return x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT;
        }
        
        function addMaterial(x, y, material, radius = 3) {
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (isValidPos(nx, ny) && Math.sqrt(dx*dx + dy*dy) <= radius) {
                        if ((grid[ny][nx] === EMPTY || material === ERASER) && Math.random() < 0.7) {
                            if (material === ERASER) {
                                // Eraser removes whatever is there
                                grid[ny][nx] = EMPTY;
                                fireLifeGrid[ny][nx] = 0;
                                steamLifeGrid[ny][nx] = 0;
                                acidLifeGrid[ny][nx] = 0;
                            } else {
                                grid[ny][nx] = material;
                                if (material === FIRE) {
                                    fireLifeGrid[ny][nx] = materials[FIRE].life;
                                } else if (material === STEAM) {
                                    steamLifeGrid[ny][nx] = materials[STEAM].life;
                                } else if (material === ACID) {
                                    acidLifeGrid[ny][nx] = materials[ACID].life;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Fractal tree growth functions
        function startTreeGrowth(x, y) {
            // Start growing a tree from this position
            treeGrowthQueue.push({
                x: x,
                y: y,
                direction: 0, // 0 = up, -1 = left, 1 = right
                length: Math.floor(Math.random() * 8) + 12, // 12-20 pixels tall
                thickness: 3,
                generation: 0,
                age: 0
            });
        }
        
        function growFractalTree(treeNode) {
            if (treeNode.age >= treeNode.length || !isValidPos(treeNode.x, treeNode.y)) {
                return false; // Tree segment finished
            }
            
            // Calculate growth direction
            let dx = 0, dy = -1; // Default: grow up
            if (treeNode.direction === -1) { // Left branch
                dx = -1;
                dy = -1;
            } else if (treeNode.direction === 1) { // Right branch
                dx = 1;
                dy = -1;
            }
            
            // Add some randomness to growth
            if (Math.random() < 0.3) {
                dx += (Math.random() - 0.5) * 0.5;
            }
            
            // Grow the tree segment
            for (let t = 0; t < treeNode.thickness; t++) {
                const growX = Math.floor(treeNode.x + (Math.random() - 0.5) * treeNode.thickness);
                const growY = treeNode.y;
                
                if (isValidPos(growX, growY) && grid[growY][growX] === EMPTY) {
                    grid[growY][growX] = TREE;
                }
            }
            
            // Move to next position
            treeNode.x += dx;
            treeNode.y += dy;
            treeNode.age++;
            
            // Create branches at certain points
            if (treeNode.generation < 3 && treeNode.age > 3 && treeNode.age % 4 === 0 && Math.random() < 0.6) {
                // Create left branch
                if (Math.random() < 0.5) {
                    treeGrowthQueue.push({
                        x: treeNode.x,
                        y: treeNode.y,
                        direction: -1,
                        length: Math.floor(treeNode.length * 0.7),
                        thickness: Math.max(1, treeNode.thickness - 1),
                        generation: treeNode.generation + 1,
                        age: 0
                    });
                }
                
                // Create right branch
                if (Math.random() < 0.5) {
                    treeGrowthQueue.push({
                        x: treeNode.x,
                        y: treeNode.y,
                        direction: 1,
                        length: Math.floor(treeNode.length * 0.7),
                        thickness: Math.max(1, treeNode.thickness - 1),
                        generation: treeNode.generation + 1,
                        age: 0
                    });
                }
            }
            
            return true; // Continue growing
        }
        
        function updateSimulation() {
            if (isPaused) return;
            
            // Process tree growth
            for (let i = treeGrowthQueue.length - 1; i >= 0; i--) {
                const treeNode = treeGrowthQueue[i];
                if (!growFractalTree(treeNode)) {
                    treeGrowthQueue.splice(i, 1); // Remove finished tree segments
                }
            }
            
            // Create new empty grids for next frame
            const newGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(EMPTY));
            const newFireLifeGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            const newSteamLifeGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            const newAcidLifeGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            
            // Process from bottom to top, left to right
            for (let y = GRID_HEIGHT - 1; y >= 0; y--) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = grid[y][x];
                    
                    if (cell === EMPTY) continue;
                    
                    // Try to move particle
                    let destX = x, destY = y;
                    
                    // Handle falling for falling materials
                    if (y < GRID_HEIGHT - 1 && (cell === SAND || cell === DIRT || cell === WATER || cell === ACID)) {
                        // Water + dirt interaction
                        if (cell === WATER && grid[y + 1][x] === DIRT && Math.random() < 0.02) {
                            // Water hits dirt - both become tree
                            newGrid[y + 1][x] = TREE;
                            startTreeGrowth(x, y);
                            continue; // Water is consumed
                        }
                        
                        // Check if can fall down
                        if (grid[y + 1][x] === EMPTY) {
                            destY = y + 1;
                        }
                        // Try diagonal fall
                        else if ((cell === SAND || cell === DIRT) && Math.random() < 0.7) {
                            if (x > 0 && grid[y + 1][x - 1] === EMPTY && Math.random() < 0.5) {
                                destX = x - 1;
                                destY = y + 1;
                            } else if (x < GRID_WIDTH - 1 && grid[y + 1][x + 1] === EMPTY) {
                                destX = x + 1;
                                destY = y + 1;
                            }
                        }
                        // Water horizontal flow when blocked
                        else if ((cell === WATER || cell === ACID) && Math.random() < 0.4) {
                            if (x > 0 && grid[y][x - 1] === EMPTY && Math.random() < 0.5) {
                                destX = x - 1;
                            } else if (x < GRID_WIDTH - 1 && grid[y][x + 1] === EMPTY) {
                                destX = x + 1;
                            }
                        }
                    }
                    
                    // Steam rises
                    else if (cell === STEAM && y > 0 && Math.random() < 0.4) {
                        if (grid[y - 1][x] === EMPTY) {
                            destY = y - 1;
                        }
                        // Steam spreads sideways if can't rise
                        else if (Math.random() < 0.3) {
                            if (x > 0 && grid[y][x - 1] === EMPTY && Math.random() < 0.5) {
                                destX = x - 1;
                            } else if (x < GRID_WIDTH - 1 && grid[y][x + 1] === EMPTY) {
                                destX = x + 1;
                            }
                        }
                    }
                    
                    // Fire rises slightly
                    else if (cell === FIRE && y > 0 && Math.random() < 0.1) {
                        if (grid[y - 1][x] === EMPTY) {
                            destY = y - 1;
                        }
                    }
                    
                    // Place particle in destination (if not occupied)
                    if (newGrid[destY][destX] === EMPTY) {
                        newGrid[destY][destX] = cell;
                        
                        // Copy life values
                        if (cell === FIRE) {
                            const newLife = Math.max(0, fireLifeGrid[y][x] - 1);
                            if (newLife > 0) {
                                newFireLifeGrid[destY][destX] = newLife;
                            } else {
                                newGrid[destY][destX] = EMPTY; // Fire dies
                            }
                        } else if (cell === STEAM) {
                            const newLife = Math.max(0, steamLifeGrid[y][x] - 1);
                            if (newLife > 0) {
                                newSteamLifeGrid[destY][destX] = newLife;
                            } else {
                                newGrid[destY][destX] = EMPTY; // Steam dissipates
                            }
                        } else if (cell === ACID) {
                            const newLife = Math.max(0, acidLifeGrid[y][x] - 1);
                            if (newLife > 0) {
                                newAcidLifeGrid[destY][destX] = newLife;
                            } else {
                                newGrid[destY][destX] = EMPTY; // Acid evaporates
                            }
                        }
                    } else {
                        // Destination occupied, try to place in original position
                        if (newGrid[y][x] === EMPTY) {
                            newGrid[y][x] = cell;
                            // Copy life values to original position
                            if (cell === FIRE) newFireLifeGrid[y][x] = fireLifeGrid[y][x];
                            if (cell === STEAM) newSteamLifeGrid[y][x] = steamLifeGrid[y][x];
                            if (cell === ACID) newAcidLifeGrid[y][x] = acidLifeGrid[y][x];
                        }
                    }
                }
            }
            
            // Second pass: Handle interactions and transformations
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = newGrid[y][x];
                    
                    // Fire interactions
                    if (cell === FIRE) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValidPos(nx, ny)) {
                                    const neighbor = newGrid[ny][nx];
                                    
                                    // Fire spreads to trees
                                    if (materials[neighbor]?.flammable && Math.random() < 0.05) {
                                        newGrid[ny][nx] = FIRE;
                                        newFireLifeGrid[ny][nx] = materials[FIRE].life;
                                    }
                                    // Fire turns sand to glass
                                    else if (neighbor === SAND && Math.random() < 0.02) {
                                        newGrid[ny][nx] = GLASS;
                                    }
                                    // Fire turns water to steam
                                    else if (neighbor === WATER && Math.random() < 0.08) {
                                        newGrid[ny][nx] = STEAM;
                                        newSteamLifeGrid[ny][nx] = materials[STEAM].life;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Water interactions
                    else if (cell === WATER) {
                        // Water extinguishes fire
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValidPos(nx, ny) && newGrid[ny][nx] === FIRE && Math.random() < 0.3) {
                                    newGrid[ny][nx] = EMPTY;
                                    newFireLifeGrid[ny][nx] = 0;
                                }
                            }
                        }
                        
                        // Dirt + Water horizontal interaction
                        const left = x > 0 ? newGrid[y][x - 1] : null;
                        const right = x < GRID_WIDTH - 1 ? newGrid[y][x + 1] : null;
                        
                        if ((left === DIRT || right === DIRT) && Math.random() < 0.008) {
                            // Remove water and convert dirt to tree
                            newGrid[y][x] = EMPTY;
                            if (left === DIRT) {
                                newGrid[y][x - 1] = TREE;
                                startTreeGrowth(x - 1, y - 1);
                            } else if (right === DIRT) {
                                newGrid[y][x + 1] = TREE;
                                startTreeGrowth(x + 1, y - 1);
                            }
                        }
                    }
                    
                    // Acid interactions
                    else if (cell === ACID) {
                        // Acid corrodes neighboring materials
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValidPos(nx, ny) && Math.random() < 0.03) {
                                    const neighbor = newGrid[ny][nx];
                                    // Acid dissolves most materials except glass and fire
                                    if (neighbor !== EMPTY && neighbor !== ACID && neighbor !== GLASS && neighbor !== FIRE) {
                                        newGrid[ny][nx] = EMPTY;
                                        // Clear life grids for dissolved materials
                                        if (neighbor === FIRE) newFireLifeGrid[ny][nx] = 0;
                                        if (neighbor === STEAM) newSteamLifeGrid[ny][nx] = 0;
                                        if (neighbor === ACID) newAcidLifeGrid[ny][nx] = 0;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            grid = newGrid;
            fireLifeGrid = newFireLifeGrid;
            steamLifeGrid = newSteamLifeGrid;
            acidLifeGrid = newAcidLifeGrid;
        }
        
        function renderGrid() {
            // Clear image data
            for (let i = 0; i < imageData.data.length; i += 4) {
                imageData.data[i] = 0;     // R
                imageData.data[i + 1] = 0; // G
                imageData.data[i + 2] = 0; // B
                imageData.data[i + 3] = 255; // A
            }
            
            // Draw grid to image data
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = grid[y][x];
                    if (cell !== EMPTY) {
                        const index = (y * GRID_WIDTH + x) * 4;
                        let color = getRandomColor(cell);
                        
                        // Modify fire color based on life
                        if (cell === FIRE) {
                            const lifeRatio = fireLifeGrid[y][x] / materials[FIRE].life;
                            color = [
                                Math.floor(color[0] * lifeRatio),
                                Math.floor(color[1] * lifeRatio),
                                Math.floor(color[2] * lifeRatio),
                                255
                            ];
                        }
                        // Modify steam opacity based on life
                        else if (cell === STEAM) {
                            const lifeRatio = steamLifeGrid[y][x] / materials[STEAM].life;
                            color = [
                                color[0],
                                color[1],
                                color[2],
                                Math.floor(color[3] * lifeRatio)
                            ];
                        }
                        // Modify acid intensity based on life
                        else if (cell === ACID) {
                            const lifeRatio = acidLifeGrid[y][x] / materials[ACID].life;
                            color = [
                                Math.floor(color[0] * lifeRatio),
                                Math.floor(color[1] * lifeRatio),
                                Math.floor(color[2] * lifeRatio),
                                255
                            ];
                        }
                        
                        imageData.data[index] = color[0];     // R
                        imageData.data[index + 1] = color[1]; // G
                        imageData.data[index + 2] = color[2]; // B
                        imageData.data[index + 3] = color[3]; // A
                    }
                }
            }
            
            // Create a temporary canvas for the pixel data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = GRID_WIDTH;
            tempCanvas.height = GRID_HEIGHT;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);
            
            // Scale up to main canvas
            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempCanvas, 0, 0, GRID_WIDTH, GRID_HEIGHT, 0, 0, canvas.width, canvas.height);
        }
        
        function clearGrid() {
            initializeGrids();
            treeGrowthQueue = []; // Clear tree growth queue
        }
        
        function resizeCanvas() {
            const newGridWidth = Math.floor(window.innerWidth / CELL_SIZE);
            const newGridHeight = Math.floor(window.innerHeight / CELL_SIZE);
            
            // Only resize if dimensions actually changed
            if (newGridWidth !== GRID_WIDTH || newGridHeight !== GRID_HEIGHT) {
                // Store old grid data
                const oldGrid = grid;
                const oldFireLife = fireLifeGrid;
                const oldSteamLife = steamLifeGrid;
                const oldAcidLife = acidLifeGrid;
                const oldWidth = GRID_WIDTH;
                const oldHeight = GRID_HEIGHT;
                
                // Update dimensions
                GRID_WIDTH = newGridWidth;
                GRID_HEIGHT = newGridHeight;
                canvas.width = GRID_WIDTH * CELL_SIZE;
                canvas.height = GRID_HEIGHT * CELL_SIZE;
                
                // Initialize new grids
                initializeGrids();
                
                // Copy over existing data if possible
                if (oldGrid) {
                    const copyWidth = Math.min(oldWidth, GRID_WIDTH);
                    const copyHeight = Math.min(oldHeight, GRID_HEIGHT);
                    
                    for (let y = 0; y < copyHeight; y++) {
                        for (let x = 0; x < copyWidth; x++) {
                            grid[y][x] = oldGrid[y][x];
                            fireLifeGrid[y][x] = oldFireLife[y][x];
                            steamLifeGrid[y][x] = oldSteamLife[y][x];
                            acidLifeGrid[y][x] = oldAcidLife[y][x];
                        }
                    }
                }
            }
        }
        
        function togglePause() {
            isPaused = !isPaused;
        }
        
        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const pos = getGridPos(e.clientX, e.clientY);
            mouseX = pos.x;
            mouseY = pos.y;
            addMaterial(mouseX, mouseY, selectedMaterial);
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isMouseDown) {
                const pos = getGridPos(e.clientX, e.clientY);
                mouseX = pos.x;
                mouseY = pos.y;
                addMaterial(mouseX, mouseY, selectedMaterial);
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });
        
        // Keyboard events
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                togglePause();
            }
        });
        
        // Window resize event
        window.addEventListener('resize', resizeCanvas);
        
        // Initial resize to set proper size
        resizeCanvas();
        
        // Main game loop
        function gameLoop() {
            updateSimulation();
            renderGrid();
            requestAnimationFrame(gameLoop);
        }
        
        // Start the simulation
        gameLoop();
    </script>
</body>
</html>