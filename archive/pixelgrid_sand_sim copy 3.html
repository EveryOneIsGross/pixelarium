<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixelgrid Sand Simulation</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
        }
        canvas { 
            display: block; 
            image-rendering: pixelated;
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
            background: #333;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background: #555;
        }
        #swatch {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .material-btn {
            width: 80px;
            height: 30px;
            border: 2px solid #666;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        .material-btn.selected {
            border-color: #fff;
            box-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>
    <div id="controls">
        <div>Click and drag to add materials</div>
        <button onclick="clearGrid()">Clear</button>
        <button onclick="togglePause()">[SPACE] Pause</button>
    </div>
    <div id="swatch">
        <div class="material-btn selected" onclick="selectMaterial('SAND')" style="background: #dcb870; color: #000;">SAND</div>
        <div class="material-btn" onclick="selectMaterial('WATER')" style="background: #4a90e2; color: #fff;">WATER</div>
        <div class="material-btn" onclick="selectMaterial('FIRE')" style="background: #ff6b35; color: #fff;">FIRE</div>
        <div class="material-btn" onclick="selectMaterial('DIRT')" style="background: #8b4513; color: #fff;">DIRT</div>
        <div class="material-btn" onclick="selectMaterial('TREE')" style="background: #228b22; color: #fff;">TREE</div>
        <div class="material-btn" onclick="selectMaterial('GLASS')" style="background: #b4dcf0; color: #000;">GLASS</div>
        <div class="material-btn" onclick="selectMaterial('STEAM')" style="background: #f0f0f0; color: #000;">STEAM</div>
        <div class="material-btn" onclick="selectMaterial('ACID')" style="background: #32ff32; color: #000;">ACID</div>
        <div class="material-btn" onclick="selectMaterial('ERASER')" style="background: #ff64ff; color: #000;">ERASER</div>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Grid settings - dynamically sized to browser window
        const CELL_SIZE = 3;
        let GRID_WIDTH = Math.floor(window.innerWidth / CELL_SIZE);
        let GRID_HEIGHT = Math.floor(window.innerHeight / CELL_SIZE);
        
        canvas.width = GRID_WIDTH * CELL_SIZE;
        canvas.height = GRID_HEIGHT * CELL_SIZE;
        
        // Material types
        const EMPTY = 0;
        const SAND = 1;
        const WATER = 2;
        const FIRE = 3;
        const DIRT = 4;
        const TREE = 5;
        const GLASS = 6;
        const STEAM = 7;
        const ACID = 8;
        const ERASER = 9;
        const DEAD_TREE = 10;
        
        // Current selected material
        let selectedMaterial = SAND;
        
        // Material properties
        const materials = {
            [EMPTY]: { density: 0, flammable: false, liquid: false },
            [SAND]: { density: 3, flammable: false, liquid: false },
            [WATER]: { density: 2, flammable: false, liquid: true },
            [FIRE]: { density: 1, flammable: false, liquid: false, life: 60 },
            [DIRT]: { density: 4, flammable: false, liquid: false },
            [TREE]: { density: 5, flammable: true, liquid: false },
            [GLASS]: { density: 4, flammable: false, liquid: false },
            [STEAM]: { density: 0.5, flammable: false, liquid: false, life: 120 },
            [ACID]: { density: 2.5, flammable: false, liquid: true, life: 300 },
            [ERASER]: { density: 1, flammable: false, liquid: false },
            [DEAD_TREE]: { density: 5, flammable: true, liquid: false }
        };
        
        // Colors for each material
        const materialColors = {
            [EMPTY]: [[0, 0, 0, 255]],
            [SAND]: [
                [220, 184, 112, 255],
                [210, 174, 102, 255],
                [200, 164, 92, 255],
                [190, 154, 82, 255]
            ],
            [WATER]: [
                [74, 144, 226, 255],
                [64, 134, 216, 255],
                [84, 154, 236, 255],
                [54, 124, 206, 255]
            ],
            [FIRE]: [
                [255, 107, 53, 255],
                [255, 140, 0, 255],
                [255, 69, 0, 255],
                [255, 165, 0, 255]
            ],
            [DIRT]: [
                [139, 69, 19, 255],
                [160, 82, 45, 255],
                [101, 67, 33, 255],
                [120, 75, 25, 255]
            ],
            [TREE]: [
                [34, 139, 34, 255],
                [46, 125, 50, 255],
                [56, 142, 60, 255],
                [27, 94, 32, 255]
            ],
            [GLASS]: [
                [180, 220, 240, 200],
                [170, 210, 230, 200],
                [190, 230, 250, 200],
                [160, 200, 220, 200]
            ],
            [STEAM]: [
                [240, 240, 240, 150],
                [230, 230, 230, 140],
                [250, 250, 250, 160],
                [220, 220, 220, 130]
            ],
            [ACID]: [
                [50, 255, 50, 255],
                [40, 245, 40, 255],
                [60, 255, 60, 255],
                [30, 235, 30, 255]
            ],
            [ERASER]: [
                [255, 100, 255, 255],
                [245, 90, 245, 255],
                [255, 110, 255, 255],
                [235, 80, 235, 255]
            ],
            [DEAD_TREE]: [
                [101, 67, 33, 255],
                [120, 75, 25, 255],
                [90, 60, 30, 255],
                [110, 70, 35, 255]
            ]
        };
        
        // Grid and image data
        let grid, fireLifeGrid, steamLifeGrid, acidLifeGrid, imageData;
        let treeGrowthQueue = []; // Queue for tree growth patterns
        let treeUpdateCounter = 0; // Counter for tree updates (slower than main loop)
        let treeDecompositionGrid; // Grid to track decomposing trees
        
        function initializeGrids() {
            grid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(EMPTY));
            fireLifeGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            steamLifeGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            acidLifeGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            treeDecompositionGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            imageData = ctx.createImageData(GRID_WIDTH, GRID_HEIGHT);
        }
        
        initializeGrids();
        
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let isPaused = false;
        
        function getRandomColor(material) {
            const colors = materialColors[material];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        function selectMaterial(materialName) {
            const materialMap = { SAND, WATER, FIRE, DIRT, TREE, GLASS, STEAM, ACID, ERASER, DEAD_TREE };
            selectedMaterial = materialMap[materialName];
            
            // Update UI
            document.querySelectorAll('.material-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');
        }
        
        function getGridPos(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((clientX - rect.left) / CELL_SIZE);
            const y = Math.floor((clientY - rect.top) / CELL_SIZE);
            return { x, y };
        }
        
        function isValidPos(x, y) {
            return x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT;
        }
        
        function addMaterial(x, y, material, radius = 3) {
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (isValidPos(nx, ny) && Math.sqrt(dx*dx + dy*dy) <= radius) {
                        if ((grid[ny][nx] === EMPTY || material === ERASER) && Math.random() < 0.7) {
                            if (material === ERASER) {
                                // Eraser removes whatever is there
                                grid[ny][nx] = EMPTY;
                                fireLifeGrid[ny][nx] = 0;
                                steamLifeGrid[ny][nx] = 0;
                                acidLifeGrid[ny][nx] = 0;
                                treeDecompositionGrid[ny][nx] = 0;
                            } else {
                                grid[ny][nx] = material;
                                if (material === FIRE) {
                                    fireLifeGrid[ny][nx] = materials[FIRE].life;
                                } else if (material === STEAM) {
                                    steamLifeGrid[ny][nx] = materials[STEAM].life;
                                } else if (material === ACID) {
                                    acidLifeGrid[ny][nx] = materials[ACID].life;
                                } else if (material === DEAD_TREE) {
                                    treeDecompositionGrid[ny][nx] = 180; // Start decomposition timer
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Fractal tree growth functions
        function startTreeGrowth(x, y) {
            // Start growing a tree from this position
            treeGrowthQueue.push({
                x: x,
                y: y,
                direction: 0, // 0 = up, -1 = left, 1 = right
                length: Math.floor(Math.random() * 8) + 12, // 12-20 pixels tall
                thickness: 3,
                generation: 0,
                age: 0
            });
        }
        
        function growFractalTree(treeNode) {
            if (treeNode.age >= treeNode.length || !isValidPos(treeNode.x, treeNode.y)) {
                return false; // Tree segment finished
            }
            
            // Calculate growth direction
            let dx = 0, dy = -1; // Default: grow up
            if (treeNode.direction === -1) { // Left branch
                dx = -1;
                dy = -1;
            } else if (treeNode.direction === 1) { // Right branch
                dx = 1;
                dy = -1;
            }
            
            // Add some randomness to growth
            if (Math.random() < 0.3) {
                dx += (Math.random() - 0.5) * 0.5;
            }
            
            // Grow the tree segment
            for (let t = 0; t < treeNode.thickness; t++) {
                const growX = Math.floor(treeNode.x + (Math.random() - 0.5) * treeNode.thickness);
                const growY = treeNode.y;
                
                if (isValidPos(growX, growY) && grid[growY][growX] === EMPTY) {
                    grid[growY][growX] = TREE;
                }
            }
            
            // Move to next position
            treeNode.x += dx;
            treeNode.y += dy;
            treeNode.age++;
            
            // Create branches at certain points
            if (treeNode.generation < 3 && treeNode.age > 3 && treeNode.age % 4 === 0 && Math.random() < 0.6) {
                // Create left branch
                if (Math.random() < 0.5) {
                    treeGrowthQueue.push({
                        x: treeNode.x,
                        y: treeNode.y,
                        direction: -1,
                        length: Math.floor(treeNode.length * 0.7),
                        thickness: Math.max(1, treeNode.thickness - 1),
                        generation: treeNode.generation + 1,
                        age: 0
                    });
                }
                
                // Create right branch
                if (Math.random() < 0.5) {
                    treeGrowthQueue.push({
                        x: treeNode.x,
                        y: treeNode.y,
                        direction: 1,
                        length: Math.floor(treeNode.length * 0.7),
                        thickness: Math.max(1, treeNode.thickness - 1),
                        generation: treeNode.generation + 1,
                        age: 0
                    });
                }
            }
            
            return true; // Continue growing
        }
        
        // Tree behavior functions
        function findNearestWater(x, y, maxDistance = 15) {
            let nearest = null;
            let minDistance = Infinity;
            
            for (let checkY = Math.max(0, y - maxDistance); checkY < Math.min(GRID_HEIGHT, y + maxDistance + 1); checkY++) {
                for (let checkX = Math.max(0, x - maxDistance); checkX < Math.min(GRID_WIDTH, x + maxDistance + 1); checkX++) {
                    if (grid[checkY][checkX] === WATER) {
                        const distance = Math.sqrt((checkX - x) * (checkX - x) + (checkY - y) * (checkY - y));
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearest = { x: checkX, y: checkY, distance: distance };
                        }
                    }
                }
            }
            
            return nearest;
        }
        
        function countNearbyTrees(x, y, radius = 3) {
            let count = 0;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    // Only count living trees, not dead trees
                    if (isValidPos(nx, ny) && grid[ny][nx] === TREE) {
                        count++;
                    }
                }
            }
            return count;
        }
        
        function updateTreeDecomposition() {
            // Process decomposition every frame
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (grid[y][x] === DEAD_TREE && treeDecompositionGrid[y][x] > 0) {
                        treeDecompositionGrid[y][x]--;
                        
                        // Convert to dirt when decomposition is complete
                        if (treeDecompositionGrid[y][x] <= 0) {
                            grid[y][x] = DIRT;
                        }
                    }
                }
            }
        }
        
        function updateTreeBehavior() {
            // Only update trees every 30 frames for performance
            if (treeUpdateCounter % 30 !== 0) return;
            
            const treesToProcess = [];
            
            // Find all tree positions
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (grid[y][x] === TREE) {
                        treesToProcess.push({ x, y });
                    }
                }
            }
            
            // Process each tree
            for (const tree of treesToProcess) {
                const waterInfo = findNearestWater(tree.x, tree.y);
                const nearbyTreeCount = countNearbyTrees(tree.x, tree.y);
                
                // Trees die only if isolated (1 neighbor) AND network lacks water access
                let adjacentTreeCount = 0;
                const adjacentTrees = [];
                
                // Count directly adjacent trees (1-pixel radius)
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = tree.x + dx;
                        const ny = tree.y + dy;
                        if (isValidPos(nx, ny) && grid[ny][nx] === TREE) {
                            adjacentTreeCount++;
                            adjacentTrees.push({ x: nx, y: ny });
                        }
                    }
                }
                
                // Only consider death if tree has exactly 1 neighbor (isolated/end of branch)
                if (adjacentTreeCount === 1) {
                    // Check if this tree or its network has water access
                    let networkHasWater = false;
                    
                    // Check if this tree has water access
                    if (waterInfo && waterInfo.distance <= 15) {
                        networkHasWater = true;
                    }
                    
                    // Check if the single neighbor has water access
                    if (!networkHasWater && adjacentTrees.length > 0) {
                        const neighbor = adjacentTrees[0];
                        const neighborWater = findNearestWater(neighbor.x, neighbor.y);
                        if (neighborWater && neighborWater.distance <= 15) {
                            networkHasWater = true;
                        }
                    }
                    
                    // Only die if isolated AND no water access in local network
                    if (!networkHasWater && Math.random() < 0.03) { // 3% chance to die when isolated without water
                        grid[tree.y][tree.x] = DEAD_TREE;
                        treeDecompositionGrid[tree.y][tree.x] = 180;
                        continue;
                    }
                }
                
                // Determine growth behavior based on clustering
                const isClustered = nearbyTreeCount >= 3;
                const growthChance = isClustered ? 0.12 : 0.08; // Higher chance when clustered
                
                // Trees grow toward water or branch when clustered
                if (waterInfo && waterInfo.distance <= 8 && Math.random() < growthChance) {
                    const dx = waterInfo.x - tree.x;
                    const dy = waterInfo.y - tree.y;
                    
                    // Normalize direction
                    const dirX = dx > 0 ? 1 : (dx < 0 ? -1 : 0);
                    const dirY = dy > 0 ? 1 : (dy < 0 ? -1 : 0);
                    
                    const candidates = [];
                    
                    if (isClustered) {
                        // When clustered, prefer branching in multiple directions
                        // Add perpendicular directions to main growth
                        if (dirX !== 0) {
                            candidates.push({ x: tree.x, y: tree.y - 1 }); // Up
                            candidates.push({ x: tree.x, y: tree.y + 1 }); // Down
                        }
                        if (dirY !== 0) {
                            candidates.push({ x: tree.x - 1, y: tree.y }); // Left
                            candidates.push({ x: tree.x + 1, y: tree.y }); // Right
                        }
                        
                        // Also add diagonal branching
                        candidates.push({ x: tree.x + dirX, y: tree.y - 1 });
                        candidates.push({ x: tree.x + dirX, y: tree.y + 1 });
                        candidates.push({ x: tree.x - dirX, y: tree.y - 1 });
                        candidates.push({ x: tree.x - dirX, y: tree.y + 1 });
                        
                        // Still include main direction but with lower priority
                        if (dirX !== 0) candidates.push({ x: tree.x + dirX, y: tree.y });
                        if (dirY !== 0) candidates.push({ x: tree.x, y: tree.y + dirY });
                    } else {
                        // When not clustered, prefer growing toward water
                        if (dirX !== 0) candidates.push({ x: tree.x + dirX, y: tree.y });
                        if (dirY !== 0) candidates.push({ x: tree.x, y: tree.y + dirY });
                        
                        // Add adjacent empty spaces as backup
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                candidates.push({ x: tree.x + dx, y: tree.y + dy });
                            }
                        }
                    }
                    
                    // Shuffle candidates for randomness
                    for (let i = candidates.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
                    }
                    
                    // Try to grow to candidate positions
                    let grownCount = 0;
                    const maxGrowth = isClustered ? (Math.random() < 0.3 ? 2 : 1) : 1; // Sometimes branch twice when clustered
                    
                    for (const candidate of candidates) {
                        if (grownCount >= maxGrowth) break;
                        
                        if (isValidPos(candidate.x, candidate.y)) {
                            const targetCell = grid[candidate.y][candidate.x];
                            
                            // Trees can grow into empty space or through dirt
                            if (targetCell === EMPTY || targetCell === DIRT) {
                                // Check if this position isn't too crowded
                                const nearbyAtCandidate = countNearbyTrees(candidate.x, candidate.y, 2);
                                if (nearbyAtCandidate < 8) { // Prevent overcrowding (reduced from 6 to allow denser growth)
                                    grid[candidate.y][candidate.x] = TREE;
                                    grownCount++;
                                    
                                    // If growing through dirt, increase growth chance slightly (nutrient bonus)
                                    if (targetCell === DIRT && Math.random() < 0.2 && grownCount < maxGrowth) {
                                        // Bonus growth chance when consuming dirt
                                        continue; // Try to grow one more time
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        function updateSimulation() {
            if (isPaused) return;
            
            // Continuous material placement while mouse is held down
            if (isMouseDown && isValidPos(mouseX, mouseY)) {
                // Add material every few frames for continuous flow
                if (treeUpdateCounter % 3 === 0) { // Every 3 frames
                    addMaterial(mouseX, mouseY, selectedMaterial);
                }
            }
            
            // Increment tree update counter
            treeUpdateCounter++;
            
            // Process tree growth (fractal growth)
            for (let i = treeGrowthQueue.length - 1; i >= 0; i--) {
                const treeNode = treeGrowthQueue[i];
                if (!growFractalTree(treeNode)) {
                    treeGrowthQueue.splice(i, 1); // Remove finished tree segments
                }
            }
            
            // Process tree behavior (movement toward water, death)
            updateTreeBehavior();
            
            // Process tree decomposition
            updateTreeDecomposition();
            
            // Create new empty grids for next frame
            const newGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(EMPTY));
            const newFireLifeGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            const newSteamLifeGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            const newAcidLifeGrid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
            
            // Process from bottom to top, left to right
            for (let y = GRID_HEIGHT - 1; y >= 0; y--) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = grid[y][x];
                    
                    if (cell === EMPTY) continue;
                    
                    // Try to move particle
                    let destX = x, destY = y;
                    
                    // Handle falling for falling materials
                    if (y < GRID_HEIGHT - 1 && (cell === SAND || cell === DIRT || cell === WATER || cell === ACID)) {
                        // Water + dirt interaction
                        if (cell === WATER && grid[y + 1][x] === DIRT && Math.random() < 0.02) {
                            // Water hits dirt - both become tree
                            newGrid[y + 1][x] = TREE;
                            startTreeGrowth(x, y);
                            continue; // Water is consumed
                        }
                        
                        // Check if can fall down
                        if (grid[y + 1][x] === EMPTY) {
                            destY = y + 1;
                        }
                        // Sand and dirt sink through water (density-based)
                        else if ((cell === SAND || cell === DIRT) && grid[y + 1][x] === WATER) {
                            destY = y + 1;
                        }
                        // Try diagonal fall
                        else if ((cell === SAND || cell === DIRT) && Math.random() < 0.7) {
                            const leftDiag = x > 0 ? grid[y + 1][x - 1] : null;
                            const rightDiag = x < GRID_WIDTH - 1 ? grid[y + 1][x + 1] : null;
                            
                            // For sand and dirt, can also fall through water diagonally
                            const canFallLeft = leftDiag === EMPTY || ((cell === SAND || cell === DIRT) && leftDiag === WATER);
                            const canFallRight = rightDiag === EMPTY || ((cell === SAND || cell === DIRT) && rightDiag === WATER);
                            
                            if (canFallLeft && canFallRight) {
                                const dir = Math.random() < 0.5 ? -1 : 1;
                                destX = x + dir;
                                destY = y + 1;
                            } else if (canFallLeft) {
                                destX = x - 1;
                                destY = y + 1;
                            } else if (canFallRight) {
                                destX = x + 1;
                                destY = y + 1;
                            }
                        }
                        // Water horizontal flow when blocked
                        else if ((cell === WATER || cell === ACID) && Math.random() < 0.4) {
                            if (x > 0 && grid[y][x - 1] === EMPTY && Math.random() < 0.5) {
                                destX = x - 1;
                            } else if (x < GRID_WIDTH - 1 && grid[y][x + 1] === EMPTY) {
                                destX = x + 1;
                            }
                        }
                    }
                    
                    // Steam rises
                    else if (cell === STEAM && y > 0 && Math.random() < 0.4) {
                        if (grid[y - 1][x] === EMPTY) {
                            destY = y - 1;
                        }
                        // Steam spreads sideways if can't rise
                        else if (Math.random() < 0.3) {
                            if (x > 0 && grid[y][x - 1] === EMPTY && Math.random() < 0.5) {
                                destX = x - 1;
                            } else if (x < GRID_WIDTH - 1 && grid[y][x + 1] === EMPTY) {
                                destX = x + 1;
                            }
                        }
                    }
                    
                    // Fire rises slightly
                    else if (cell === FIRE && y > 0 && Math.random() < 0.1) {
                        if (grid[y - 1][x] === EMPTY) {
                            destY = y - 1;
                        }
                    }
                    
                    // Place particle in destination
                    const destContent = newGrid[destY][destX];
                    
                    // Check if can displace what's at destination
                    const canDisplace = destContent === EMPTY || 
                        ((cell === SAND || cell === DIRT) && destContent === WATER);
                    
                    if (canDisplace) {
                        newGrid[destY][destX] = cell;
                        
                        // If displacing water, place it at original position
                        if (destContent === WATER && newGrid[y][x] === EMPTY) {
                            newGrid[y][x] = WATER;
                        }
                        
                        // Copy life values
                        if (cell === FIRE) {
                            const newLife = Math.max(0, fireLifeGrid[y][x] - 1);
                            if (newLife > 0) {
                                newFireLifeGrid[destY][destX] = newLife;
                            } else {
                                newGrid[destY][destX] = EMPTY; // Fire dies
                            }
                        } else if (cell === STEAM) {
                            const newLife = Math.max(0, steamLifeGrid[y][x] - 1);
                            if (newLife > 0) {
                                newSteamLifeGrid[destY][destX] = newLife;
                            } else {
                                newGrid[destY][destX] = EMPTY; // Steam dissipates
                            }
                        } else if (cell === ACID) {
                            const newLife = Math.max(0, acidLifeGrid[y][x] - 1);
                            if (newLife > 0) {
                                newAcidLifeGrid[destY][destX] = newLife;
                            } else {
                                newGrid[destY][destX] = EMPTY; // Acid evaporates
                            }
                        }
                    } else {
                        // Can't displace, try to place in original position
                        if (newGrid[y][x] === EMPTY) {
                            newGrid[y][x] = cell;
                            // Copy life values to original position
                            if (cell === FIRE) newFireLifeGrid[y][x] = fireLifeGrid[y][x];
                            if (cell === STEAM) newSteamLifeGrid[y][x] = steamLifeGrid[y][x];
                            if (cell === ACID) newAcidLifeGrid[y][x] = acidLifeGrid[y][x];
                        }
                    }
                }
            }
            
            // Second pass: Handle interactions and transformations
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = newGrid[y][x];
                    
                    // Fire interactions
                    if (cell === FIRE) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValidPos(nx, ny)) {
                                    const neighbor = newGrid[ny][nx];
                                    
                                    // Fire spreads to flammable materials (trees and dead trees)
                                    if (materials[neighbor]?.flammable && Math.random() < 0.05) {
                                        newGrid[ny][nx] = FIRE;
                                        newFireLifeGrid[ny][nx] = materials[FIRE].life;
                                        // Clear decomposition timer if burning dead tree
                                        if (neighbor === DEAD_TREE) {
                                            treeDecompositionGrid[ny][nx] = 0;
                                        }
                                    }
                                    // Fire turns sand to glass
                                    else if (neighbor === SAND && Math.random() < 0.02) {
                                        newGrid[ny][nx] = GLASS;
                                    }
                                    // Fire turns water to steam
                                    else if (neighbor === WATER && Math.random() < 0.08) {
                                        newGrid[ny][nx] = STEAM;
                                        newSteamLifeGrid[ny][nx] = materials[STEAM].life;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Water interactions
                    else if (cell === WATER) {
                        // Water extinguishes fire
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValidPos(nx, ny) && newGrid[ny][nx] === FIRE && Math.random() < 0.3) {
                                    newGrid[ny][nx] = EMPTY;
                                    newFireLifeGrid[ny][nx] = 0;
                                }
                            }
                        }
                        
                        // Already handled in dirt interactions below
                    }
                    
                    // Dirt interactions
                    else if (cell === DIRT) {
                        // Check for neighboring water to sprout trees
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue; // Skip self
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValidPos(nx, ny) && newGrid[ny][nx] === WATER && Math.random() < 0.008) {
                                    // Convert dirt to tree and consume water
                                    newGrid[y][x] = TREE;
                                    newGrid[ny][nx] = EMPTY; // Consume the water
                                    startTreeGrowth(x, y - 1); // Grow upward from dirt
                                    break; // Only one tree per dirt particle
                                }
                            }
                        }
                    }
                    
                    // Steam interactions
                    else if (cell === STEAM) {
                        // Steam condenses to water when touching glass
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValidPos(nx, ny) && newGrid[ny][nx] === GLASS && Math.random() < 0.15) {
                                    // Convert steam to water
                                    newGrid[y][x] = WATER;
                                    newSteamLifeGrid[y][x] = 0; // Clear steam life
                                    break; // Only one conversion per steam particle
                                }
                            }
                        }
                    }
                    
                    // Acid interactions
                    else if (cell === ACID) {
                        // Acid corrodes neighboring materials
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (isValidPos(nx, ny) && Math.random() < 0.03) {
                                    const neighbor = newGrid[ny][nx];
                                    // Acid dissolves most materials except glass and fire
                                    if (neighbor !== EMPTY && neighbor !== ACID && neighbor !== GLASS && neighbor !== FIRE) {
                                        newGrid[ny][nx] = EMPTY;
                                        // Clear life grids for dissolved materials
                                        if (neighbor === FIRE) newFireLifeGrid[ny][nx] = 0;
                                        if (neighbor === STEAM) newSteamLifeGrid[ny][nx] = 0;
                                        if (neighbor === ACID) newAcidLifeGrid[ny][nx] = 0;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            grid = newGrid;
            fireLifeGrid = newFireLifeGrid;
            steamLifeGrid = newSteamLifeGrid;
            acidLifeGrid = newAcidLifeGrid;
        }
        
        function renderGrid() {
            // Clear image data
            for (let i = 0; i < imageData.data.length; i += 4) {
                imageData.data[i] = 0;     // R
                imageData.data[i + 1] = 0; // G
                imageData.data[i + 2] = 0; // B
                imageData.data[i + 3] = 255; // A
            }
            
            // Draw grid to image data
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = grid[y][x];
                    if (cell !== EMPTY) {
                        const index = (y * GRID_WIDTH + x) * 4;
                        let color = getRandomColor(cell);
                        
                        // Modify fire color based on life
                        if (cell === FIRE) {
                            const lifeRatio = fireLifeGrid[y][x] / materials[FIRE].life;
                            color = [
                                Math.floor(color[0] * lifeRatio),
                                Math.floor(color[1] * lifeRatio),
                                Math.floor(color[2] * lifeRatio),
                                255
                            ];
                        }
                        // Modify steam opacity based on life
                        else if (cell === STEAM) {
                            const lifeRatio = steamLifeGrid[y][x] / materials[STEAM].life;
                            color = [
                                color[0],
                                color[1],
                                color[2],
                                Math.floor(color[3] * lifeRatio)
                            ];
                        }
                        // Modify acid intensity based on life
                        else if (cell === ACID) {
                            const lifeRatio = acidLifeGrid[y][x] / materials[ACID].life;
                            color = [
                                Math.floor(color[0] * lifeRatio),
                                Math.floor(color[1] * lifeRatio),
                                Math.floor(color[2] * lifeRatio),
                                255
                            ];
                        }
                        
                        imageData.data[index] = color[0];     // R
                        imageData.data[index + 1] = color[1]; // G
                        imageData.data[index + 2] = color[2]; // B
                        imageData.data[index + 3] = color[3]; // A
                    }
                }
            }
            
            // Create a temporary canvas for the pixel data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = GRID_WIDTH;
            tempCanvas.height = GRID_HEIGHT;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);
            
            // Scale up to main canvas
            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempCanvas, 0, 0, GRID_WIDTH, GRID_HEIGHT, 0, 0, canvas.width, canvas.height);
        }
        
        function clearGrid() {
            initializeGrids();
            treeGrowthQueue = []; // Clear tree growth queue
            treeUpdateCounter = 0; // Reset tree update counter
        }
        
        function resizeCanvas() {
            const newGridWidth = Math.floor(window.innerWidth / CELL_SIZE);
            const newGridHeight = Math.floor(window.innerHeight / CELL_SIZE);
            
            // Only resize if dimensions actually changed
            if (newGridWidth !== GRID_WIDTH || newGridHeight !== GRID_HEIGHT) {
                // Store old grid data
                const oldGrid = grid;
                const oldFireLife = fireLifeGrid;
                const oldSteamLife = steamLifeGrid;
                const oldAcidLife = acidLifeGrid;
                const oldWidth = GRID_WIDTH;
                const oldHeight = GRID_HEIGHT;
                
                // Update dimensions
                GRID_WIDTH = newGridWidth;
                GRID_HEIGHT = newGridHeight;
                canvas.width = GRID_WIDTH * CELL_SIZE;
                canvas.height = GRID_HEIGHT * CELL_SIZE;
                
                // Initialize new grids
                initializeGrids();
                
                // Copy over existing data if possible
                if (oldGrid) {
                    const copyWidth = Math.min(oldWidth, GRID_WIDTH);
                    const copyHeight = Math.min(oldHeight, GRID_HEIGHT);
                    
                    for (let y = 0; y < copyHeight; y++) {
                        for (let x = 0; x < copyWidth; x++) {
                            grid[y][x] = oldGrid[y][x];
                            fireLifeGrid[y][x] = oldFireLife[y][x];
                            steamLifeGrid[y][x] = oldSteamLife[y][x];
                            acidLifeGrid[y][x] = oldAcidLife[y][x];
                        }
                    }
                }
            }
        }
        
        function togglePause() {
            isPaused = !isPaused;
        }
        
        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const pos = getGridPos(e.clientX, e.clientY);
            mouseX = pos.x;
            mouseY = pos.y;
            addMaterial(mouseX, mouseY, selectedMaterial);
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const pos = getGridPos(e.clientX, e.clientY);
            mouseX = pos.x;
            mouseY = pos.y;
            if (isMouseDown) {
                addMaterial(mouseX, mouseY, selectedMaterial);
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });
        
        // Keyboard events
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                togglePause();
            }
        });
        
        // Window resize event
        window.addEventListener('resize', resizeCanvas);
        
        // Initial resize to set proper size
        resizeCanvas();
        
        // Main game loop
        function gameLoop() {
            updateSimulation();
            renderGrid();
            requestAnimationFrame(gameLoop);
        }
        
        // Start the simulation
        gameLoop();
    </script>
</body>
</html>